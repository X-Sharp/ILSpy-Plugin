// XSharpOutputVisitor.prg
// Created by    : fabri
// Creation Date : 3/30/2018 6:28:15 PM
// Created for   : 
// WorkStation   : FABPORTABLE

USING System
USING System.Collections.Generic
USING System.Linq
USING System.Text
USING System.ComponentModel.Composition
USING ICSharpCode.ILSpy
USING ICSharpCode.Decompiler
USING ICSharpCode.Decompiler.CSharp
USING ICSharpCode.Decompiler.CSharp.Syntax
USING ICSharpCode.Decompiler.CSharp.Syntax.PatternMatching
USING ICSharpCode.Decompiler.CSharp.Transforms
USING ICSharpCode.Decompiler.CSharp.OutputVisitor
USING ICSharpCode.Decompiler.Semantics
USING ICSharpCode.Decompiler.TypeSystem
USING Mono.Cecil


BEGIN NAMESPACE ILSpy.XSharpLanguage

    /// <summary>
    /// The XSharpOutputVisitor class.
    /// Visit/Walk all elements generated by the CSharpDecompiler, but generate the corresponding X# code
    /// See the XSharpLocalVisitor for LOCALs declaration 
    /// </summary>
    CLASS XSharpOutputVisitor IMPLEMENTS IAstVisitor
        // Fields
        INITONLY PROTECTED containerStack AS System.Collections.Generic.Stack<AstNode>
        PROTECTED isAfterSpace AS LOGIC
        PROTECTED isAtStartOfLine AS LOGIC
        INITONLY PROTECTED writer AS TokenWriter
        INITONLY PROTECTED policy AS CSharpFormattingOptions
        INITONLY PRIVATE system AS IDecompilerTypeSystem
        PRIVATE currentType AS IType
        //
        PRIVATE inMethodAttributes AS ClipperState
        PRIVATE isClipper AS LOGIC
        PRIVATE paramsList AS List<STRING>
        //
        STATIC INITONLY PRIVATE queryKeywords AS System.Collections.Generic.HashSet<STRING>
        STATIC INITONLY PRIVATE unconditionalKeywords AS System.Collections.Generic.HashSet<STRING>
        STATIC INITONLY PRIVATE maxKeywordLength AS LONG
        
        
        // Methods
        STATIC  CONSTRUCTOR()
            LOCAL keywords AS STRING[]
            //
            keywords := <STRING>{;
            "and",            "array",         "as",           "asm",           "begin",          "case",          "class",        "const",;
            "date",           "hidden",        "dispinterface","div",           "do",             "downto",        "else",         "end",;
            "enum",           "local",         "excet",         "exports",      "file",           "finalization",  "finally",       "for",;
            "function",       "goto",          "if",            "implements",   "in",             "inherit",       "instance",      "initialization",;
            "inline",         "interface",     "is",            "lock",         "library",        "mod",          "nil",            "not",;
            "object",         "of",            "or",            "out",          "packed",         "procedure",    "ptr",            "property", ;
            "raise",          "record",        "repeat",        "set",          "then",  ;
            "to",             "try",           "type",          "unit",         "until",          "using",          "var",           "while",;
            "with",           "xor",            "return",        "sequence",     "super";
            }
            //
            XSharpOutputVisitor.unconditionalKeywords := HashSet<STRING>{ keywords }
            //
            LOCAL linqKeywords AS STRING[]
            linqKeywords := <STRING>{ "from", "where", "join", "on", "equals", "into", "let", "orderby", "ascending", "descending", "select", "group", "by"}
            XSharpOutputVisitor.queryKeywords := HashSet<STRING>{ linqKeywords }
            
            XSharpOutputVisitor.maxKeywordLength := XSharpOutputVisitor.unconditionalKeywords:Concat<STRING>( XSharpOutputVisitor.queryKeywords):Max( {|s| s:Length } )
            
            
            
        CONSTRUCTOR(writer AS TokenWriter, formattingPolicy AS CSharpFormattingOptions, typeSystem AS IDecompilerTypeSystem);SUPER()
            //
            SELF:containerStack := System.Collections.Generic.Stack<AstNode>{}
            SELF:isAtStartOfLine := TRUE
            IF (writer == NULL)
                //
                THROW System.ArgumentNullException{"XSharpOutputVisitor: writer is null"}
            ENDIF
            IF (formattingPolicy == NULL)
                //
                THROW System.ArgumentNullException{"XSharpOutputVisitor: formattingPolicy is null"}
            ENDIF
            SELF:writer := writer //InsertSpecialsDecorator{InsertRequiredSpacesDecorator{writer}}
            SELF:policy := formattingPolicy
            SELF:system := typeSystem
            SELF:inMethodAttributes := ClipperState.None
            
        CONSTRUCTOR(textWriter AS System.IO.TextWriter, formattingPolicy AS CSharpFormattingOptions, typeSystem AS IDecompilerTypeSystem);SUPER()
            //
            SELF:containerStack := System.Collections.Generic.Stack<AstNode>{}
            SELF:isAtStartOfLine := TRUE
            IF (textWriter == NULL)
                //
                THROW System.ArgumentNullException{"XSharpOutputVisitor: textWriter is null"}
            ENDIF
            IF (formattingPolicy == NULL)
                //
                THROW System.ArgumentNullException{"XSharpOutputVisitor: formattingPolicy is null"}
            ENDIF
            SELF:writer := TokenWriter.Create(textWriter, formattingPolicy:IndentationString)
            SELF:policy := formattingPolicy
            SELF:system := typeSystem
            SELF:inMethodAttributes := ClipperState.None
            
        PROTECTED METHOD CanBeConfusedWithObjectInitializer(expr AS Expression) AS LOGIC
            LOCAL expression AS AssignmentExpression
            //
            expression := (AssignmentExpression)(expr)
            RETURN ((expression != NULL) .AND. (expression:Operator == AssignmentOperatorType.Assign))
            
        PROTECTED VIRTUAL METHOD CloseBrace(style AS BraceStyle) AS VOID
            //
            SWITCH style
                CASE BraceStyle.DoNotChange
                CASE BraceStyle.EndOfLine
                CASE BraceStyle.EndOfLineWithoutSpace
                CASE BraceStyle.NextLine
                    //
                    SELF:writer:Unindent()
                    //SELF:writer:WriteToken(XSRoles.RBrace, "}")
                    SELF:isAtStartOfLine := FALSE
                    RETURN
            CASE BraceStyle.NextLineShifted
                CASE BraceStyle.BannerStyle
                    //
                    //SELF:writer:WriteToken(XSRoles.RBrace, "}")
                    SELF:isAtStartOfLine := FALSE
                    SELF:writer:Unindent()
                    RETURN
                CASE BraceStyle.NextLineShifted2
                    //
                    SELF:writer:Unindent()
                    //SELF:writer:WriteToken(XSRoles.RBrace, "}")
                    SELF:isAtStartOfLine := FALSE
                    SELF:writer:Unindent()
                    RETURN
                END SWITCH
            THROW System.ArgumentOutOfRangeException{}
            
        PROTECTED VIRTUAL METHOD Comma(nextNode AS AstNode,  noSpaceAfterComma := FALSE AS LOGIC) AS VOID
            //
            SELF:Space(SELF:policy:SpaceBeforeBracketComma)
            SELF:writer:WriteToken( XSRoles.Comma, ",")
            SELF:isAfterSpace := FALSE
            SELF:Space((! noSpaceAfterComma .AND. SELF:policy:SpaceAfterBracketComma))
            
        STATIC METHOD ConvertString(text AS STRING) AS STRING
            //
            RETURN TextWriterTokenWriter.ConvertString(text)
            
        PROTECTED VIRTUAL METHOD EndNode(node AS AstNode) AS VOID
            //
            SELF:containerStack:Pop()
            SELF:writer:EndNode(node)
            
        PRIVATE METHOD GetCallChainLengthLimited(expr AS MemberReferenceExpression) AS LONG
            LOCAL expression2 AS InvocationExpression
            LOCAL expression3 AS MemberReferenceExpression
            LOCAL num AS LONG
            LOCAL expression AS MemberReferenceExpression
            //
            num := 0
            expression := expr
            WHILE (TRUE)
                expression2 := expression:Target ASTYPE InvocationExpression
                IF ( expression2 == NULL )
                    EXIT
                ENDIF
                expression3 := expression2:Target ASTYPE MemberReferenceExpression
                IF ( expression3 == NULL )
                    EXIT
                ENDIF
                // WHILE ((((expression2 := (InvocationExpression)(expression:Target) != NULL) .AND. (expression3 := (MemberReferenceExpression)(expression2:Target) != NULL)) .AND. (num < 4)))
                //
                expression := expression3
                num++
                IF (num >= 4)
                    EXIT
                ENDIF
                
            ENDDO
            RETURN num
            
        VIRTUAL METHOD ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor.VisitErrorNode(errorNode AS AstNode) AS VOID
            //
            SELF:StartNode(errorNode)
            SELF:EndNode(errorNode)
            
        VIRTUAL METHOD ICSharpCode.Decompiler.CSharp.Syntax.IAstVisitor.VisitNullNode(nullNode AS AstNode) AS VOID
            //
            
            
        PROTECTED VIRTUAL METHOD InsertNewLineWhenInMethodCallChain(expr AS MemberReferenceExpression) AS VOID
            LOCAL callChainLengthLimited AS LONG
            //
            callChainLengthLimited := SELF:GetCallChainLengthLimited(expr)
            IF (callChainLengthLimited >= 3)
                //
                IF (callChainLengthLimited == 3)
                    //
                    SELF:writer:Indent()
                ENDIF
                // XBase needs a semi colon
                SELF:WriteToken( ";" )
                SELF:writer:NewLine()
                SELF:isAtStartOfLine := TRUE
                SELF:isAfterSpace := FALSE
            ENDIF
            
        STATIC METHOD IsKeyword(identifier AS STRING, context AS AstNode) AS LOGIC
            //
            identifier := identifier:Tolower()
            //
            IF (((identifier:Length <= XSharpOutputVisitor.maxKeywordLength) .AND. (identifier:Length >= 2)) .AND. (identifier:Chars[0] >= 'a'))
                //
                IF (XSharpOutputVisitor.unconditionalKeywords:Contains(identifier))
                    //
                    RETURN TRUE
                ENDIF
                IF (XSharpOutputVisitor.queryKeywords:Contains(identifier))
                    //
                    RETURN System.Linq.Enumerable.Any<AstNode>(context:Ancestors,{ |ancestor| (ancestor IS QueryExpression) })
                ENDIF
                IF (identifier == "await")
                    //
                    FOREACH node AS AstNode IN context:Ancestors
                        //
                        IF ((node IS LambdaExpression))
                            //
                            RETURN ((LambdaExpression)node):IsAsync
                        ENDIF
                        IF ((node IS AnonymousMethodExpression))
                            //
                            RETURN ((AnonymousMethodExpression)node):IsAsync
                        ENDIF
                        IF ((node IS EntityDeclaration))
                            //
                            RETURN ((((EntityDeclaration)node):Modifiers & Modifiers.Async) == Modifiers.Async)
                        ENDIF
                    NEXT
                ENDIF
            ENDIF
            RETURN FALSE
            
        PROTECTED METHOD IsObjectOrCollectionInitializer(node AS AstNode) AS LOGIC
            //
            IF (! (node IS ArrayInitializerExpression))
                //
                RETURN FALSE
            ENDIF
            IF ((node:Parent IS ObjectCreateExpression))
                //
                RETURN (node:Role == ObjectCreateExpression.InitializerRole)
            ENDIF
            VAR nodeParent := node:Parent ASTYPE NamedExpression
            RETURN (( nodeParent != NULL) .AND. (node:Role == XSRoles.Expression))
            
        PRIVATE STATIC METHOD IsPostfixOperator(op AS UnaryOperatorType) AS LOGIC
            //
            IF ((op != UnaryOperatorType.PostIncrement) .AND. (op != UnaryOperatorType.PostDecrement))
                //
                RETURN (op == UnaryOperatorType.NullConditional)
            ENDIF
            RETURN TRUE
            
        PROTECTED METHOD LambdaNeedsParenthesis(lambdaExpression AS LambdaExpression) AS LOGIC
            LOCAL declaration AS ParameterDeclaration
            //
            IF (lambdaExpression:Parameters:Count == 1)
                //
                declaration := System.Linq.Enumerable.Single<ParameterDeclaration>(lambdaExpression:Parameters)
                IF (declaration:@@Type:IsNull)
                    //
                    RETURN (declaration:ParameterModifier > ParameterModifier.None)
                ENDIF
            ENDIF
            RETURN TRUE
            
        PROTECTED VIRTUAL METHOD LPar() AS VOID
            //
            SELF:WriteToken(XSRoles.LPar)
            
        PROTECTED VIRTUAL METHOD LBrace() AS VOID
            //
            SELF:WriteToken(XSRoles.LBrace)
            
        PROTECTED VIRTUAL METHOD RBrace() AS VOID
            //
            SELF:WriteToken(XSRoles.RBrace)
            
        PROTECTED VIRTUAL METHOD LBracket() AS VOID
            //
            SELF:WriteToken(XSRoles.LBracket)
            
        PROTECTED VIRTUAL METHOD RBracket() AS VOID
            //
            SELF:WriteToken(XSRoles.RBracket)
            
        PROTECTED VIRTUAL METHOD LChevron() AS VOID
            //
            SELF:WriteToken(XSRoles.LChevron)
            
        PROTECTED VIRTUAL METHOD RChevron() AS VOID
            //
            SELF:WriteToken(XSRoles.RChevron)                        
            
        PRIVATE METHOD MaybeNewLinesAfterUsings(node AS AstNode) AS VOID
            LOCAL nextSibling AS AstNode
            LOCAL i AS LONG
            //
            nextSibling := node:NextSibling
            WHILE (((nextSibling IS WhitespaceNode) .OR. (nextSibling IS NewLineNode)))
                //
                nextSibling := nextSibling:NextSibling
            ENDDO
            IF (((node IS UsingDeclaration) .OR. (node IS UsingAliasDeclaration)) .AND. (! (nextSibling IS UsingDeclaration) .AND. ! (nextSibling IS UsingAliasDeclaration)))
                //
                i := 0
                WHILE ((i < SELF:policy:MinimumBlankLinesAfterUsings))
                    //
                    SELF:NewLine()
                    i++
                ENDDO
            ENDIF
            
        PROTECTED VIRTUAL METHOD NewLine() AS VOID
            //
            SELF:writer:NewLine()
            SELF:isAtStartOfLine := TRUE
            SELF:isAfterSpace := FALSE
            
        PROTECTED VIRTUAL METHOD OpenBrace(style AS BraceStyle) AS VOID
            //
            SWITCH style
                CASE BraceStyle.DoNotChange
                CASE BraceStyle.EndOfLine
                CASE BraceStyle.BannerStyle
                    //
                    IF (! SELF:isAtStartOfLine)
                        //
                        SELF:Space(TRUE)
                    ENDIF
                    //SELF:writer:WriteToken(XSRoles.LBrace, "{")
                    
                CASE BraceStyle.EndOfLineWithoutSpace
                    //
                    //SELF:writer:WriteToken(XSRoles.LBrace, "{")
                    NOP
                    
                CASE BraceStyle.NextLine
                    //
                    IF (! SELF:isAtStartOfLine)
                        //
                        SELF:NewLine()
                    ENDIF
                    //SELF:writer:WriteToken(XSRoles.LBrace, "{")
                    
                CASE BraceStyle.NextLineShifted
                    //
                    SELF:NewLine()
                    SELF:writer:Indent()
                    //SELF:writer:WriteToken(XSRoles.LBrace, "{")
                    SELF:NewLine()
                CASE BraceStyle.NextLineShifted2
                    //
                    SELF:NewLine()
                    SELF:writer:Indent()
                    //SELF:writer:WriteToken(XSRoles.LBrace, "{")
                OTHERWISE
                    //
                    THROW System.ArgumentOutOfRangeException{}
            END SWITCH
            SELF:writer:Indent()
            //SELF:NewLine()
            
        PROTECTED VIRTUAL METHOD OptionalComma(pos AS AstNode) AS VOID
            //
            WHILE (((pos != NULL) .AND. (pos:NodeType == NodeType.Whitespace)))
                //
                pos := pos:NextSibling
            ENDDO
            IF ((pos != NULL) .AND. (pos:Role == XSRoles.Comma))
                //
                SELF:Comma(NULL, TRUE)
            ENDIF
            
        PROTECTED VIRTUAL METHOD OptionalSemicolon(pos AS AstNode) AS VOID
            //
            WHILE (((pos != NULL) .AND. (pos:NodeType == NodeType.Whitespace)))
                //
                pos := pos:PrevSibling
            ENDDO
            IF ((pos != NULL) .AND. (pos:Role == XSRoles.Semicolon))
                //
                SELF:Semicolon()
            ENDIF
            
        PROTECTED VIRTUAL METHOD PrintInitializerElements(elements AS AstNodeCollection<Expression>) AS VOID
            LOCAL nextLine AS BraceStyle
            LOCAL flag AS LOGIC
            LOCAL node AS AstNode
            //
            IF (SELF:policy:ArrayInitializerWrapping == Wrapping.WrapAlways)
                //
                nextLine := BraceStyle.NextLine
            ELSE
                //
                nextLine := BraceStyle.EndOfLine
            ENDIF
            SELF:OpenBrace(nextLine)
            SELF:LBrace()
            flag := TRUE
            node := NULL
            FOREACH node2 AS AstNode IN elements
                //
                IF (flag)
                    //
                    flag := FALSE
                ELSE
                    //
                    SELF:Comma(node2, TRUE)
                    SELF:WriteToken( ";" )
                    SELF:NewLine()
                ENDIF
                node := node2
                node2:AcceptVisitor(SELF)
            NEXT
            IF (node != NULL)
                //
                SELF:OptionalComma(node:NextSibling)
                SELF:WriteToken( ";" )
            ENDIF
            SELF:NewLine()
            SELF:RBrace()
            SELF:CloseBrace(nextLine)
            
        PROTECTED VIRTUAL METHOD RPar() AS VOID
            //
            SELF:WriteToken(XSRoles.RPar)
            
        PROTECTED VIRTUAL METHOD Semicolon() AS VOID
            LOCAL role AS Role
            //
            role := SELF:containerStack:Peek():Role
            IF (((role != ForStatement.InitializerRole) .AND. (role != ForStatement.IteratorRole)) .AND. (role != UsingStatement.ResourceAcquisitionRole))
                //
                //SELF:WriteToken(XSRoles.Semicolon)
                //SELF:NewLine()
            ENDIF
            
        PROTECTED VIRTUAL METHOD Space( addSpace := TRUE AS LOGIC) AS VOID
            //
            IF (addSpace .AND. ! SELF:isAfterSpace)
                //
                SELF:writer:Space()
                SELF:isAfterSpace := TRUE
            ENDIF
            
        PROTECTED VIRTUAL METHOD StartNode(node AS AstNode) AS VOID
            //
            SELF:containerStack:Push(node)
            SELF:writer:StartNode(node)
            
        VIRTUAL METHOD VisitAccessor(accessor AS Accessor) AS VOID
            LOCAL statementBraceStyle AS BraceStyle
            //
            SELF:StartNode(accessor)
            //
            SELF:WriteAttributes(accessor:Attributes)
            SELF:WriteModifiers(accessor:ModifierTokens)
            statementBraceStyle := SELF:policy:StatementBraceStyle
            IF (accessor:Role == PropertyDeclaration.GetterRole)
                //
                SELF:WriteKeyword("GET", PropertyDeclaration.GetKeywordRole)
                statementBraceStyle := SELF:policy:PropertyGetBraceStyle
            ELSE
                //
                IF (accessor:Role == PropertyDeclaration.SetterRole)
                    //
                    SELF:WriteKeyword("SET", PropertyDeclaration.SetKeywordRole)
                    statementBraceStyle := SELF:policy:PropertySetBraceStyle
                ELSE
                    //
                    IF (accessor:Role == CustomEventDeclaration.AddAccessorRole)
                        //
                        SELF:WriteKeyword("ADD", CustomEventDeclaration.AddKeywordRole)
                        statementBraceStyle := SELF:policy:EventAddBraceStyle
                    ELSE
                        //
                        IF (accessor:Role == CustomEventDeclaration.RemoveAccessorRole)
                            //
                            SELF:WriteKeyword("REMOVE", CustomEventDeclaration.RemoveKeywordRole)
                            statementBraceStyle := SELF:policy:EventRemoveBraceStyle
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
            SELF:WriteMethodBody(accessor:Body, statementBraceStyle)
            //
            IF (accessor:Role == PropertyDeclaration.GetterRole)
                //
                SELF:WriteKeyword("END")
                SELF:Space(TRUE)
                SELF:WriteKeyword("GET")
            ELSE
                //
                IF (accessor:Role == PropertyDeclaration.SetterRole)
                    //
                    SELF:WriteKeyword("END")
                    SELF:Space(TRUE)
                    SELF:WriteKeyword("SET")
                ELSE
                    //
                    IF (accessor:Role == CustomEventDeclaration.AddAccessorRole)
                        //
                        SELF:WriteKeyword("END")
                        SELF:Space(TRUE)
                        SELF:WriteKeyword("ADD")
                    ELSE
                        //
                        IF (accessor:Role == CustomEventDeclaration.RemoveAccessorRole)
                            //
                            SELF:WriteKeyword("END")
                            SELF:Space(TRUE)
                            SELF:WriteKeyword("REMOVE")
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
            SELF:NewLine()
            SELF:EndNode(accessor)
            
        VIRTUAL METHOD VisitAnonymousMethodExpression(anonymousMethodExpression AS AnonymousMethodExpression) AS VOID
            //
            SELF:StartNode(anonymousMethodExpression)
            IF (anonymousMethodExpression:IsAsync)
                //
                SELF:WriteKeyword(AnonymousMethodExpression.AsyncModifierRole)
                SELF:Space(TRUE)
            ENDIF
            SELF:WriteToken( "{" )
            IF (anonymousMethodExpression:HasParameterList)
                //
                SELF:Space(SELF:policy:SpaceBeforeMethodDeclarationParentheses)
                SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)anonymousMethodExpression:Parameters , SELF:policy:SpaceWithinMethodDeclarationParentheses)
            ENDIF
            SELF:Space(TRUE)
            SELF:WriteToken(XSRoles.Arrow)
            SELF:WriteBlock(anonymousMethodExpression:Body, SELF:policy:AnonymousMethodBraceStyle)
            SELF:WriteToken( "}" )
            SELF:EndNode(anonymousMethodExpression)
            
            
            
            
            
        VIRTUAL METHOD VisitAnonymousTypeCreateExpression(anonymousTypeCreateExpression AS AnonymousTypeCreateExpression) AS VOID
            //
            SELF:StartNode(anonymousTypeCreateExpression)
            SELF:WriteKeyword(AnonymousTypeCreateExpression.NewKeywordRole)
            SELF:PrintInitializerElements(anonymousTypeCreateExpression:Initializers)
            SELF:EndNode(anonymousTypeCreateExpression)
            
        PRIVATE METHOD VisitAnyNode(anyNode AS AnyNode) AS VOID
            //
            IF (! String.IsNullOrEmpty(anyNode:GroupName))
                //
                SELF:WriteIdentifier(anyNode:GroupName)
                SELF:WriteToken(".")
            ENDIF
            
        VIRTUAL METHOD VisitArrayCreateExpression(arrayCreateExpression AS ArrayCreateExpression) AS VOID
            //
            SELF:StartNode(arrayCreateExpression)
            IF ( arrayCreateExpression:Initializer:IsNull )
                arrayCreateExpression:@@Type:AcceptVisitor(SELF)
                IF (arrayCreateExpression:Arguments:Count > 0)
                    //
                    SELF:LBracket()
                    SELF:RBracket()
                    SELF:WriteCommaSeparatedListInBraces(arrayCreateExpression:Arguments, TRUE)
                ENDIF
                FOREACH specifier AS ArraySpecifier IN arrayCreateExpression:AdditionalArraySpecifiers
                    //
                    specifier:AcceptVisitor(SELF)
                NEXT
            ELSE
                SELF:LChevron()
                arrayCreateExpression:@@Type:AcceptVisitor(SELF)
                SELF:RChevron()
                SELF:WriteToken( ";" )
                arrayCreateExpression:Initializer:AcceptVisitor(SELF)
            ENDIF
            SELF:EndNode(arrayCreateExpression)
            
        VIRTUAL METHOD VisitArrayInitializerExpression(arrayInitializerExpression AS ArrayInitializerExpression) AS VOID
            //
            // we could have something like "List<int>{} { 1, 2, 3 }"
            // or "MyObject{}{ field1 := 1, field2 := 2 }"
            SELF:StartNode(arrayInitializerExpression)
            IF ((((arrayInitializerExpression:Elements:Count == 1) .AND. SELF:IsObjectOrCollectionInitializer(arrayInitializerExpression:Parent)) .AND. ! SELF:CanBeConfusedWithObjectInitializer(System.Linq.Enumerable.Single<Expression>(arrayInitializerExpression:Elements))) .AND. arrayInitializerExpression:LBraceToken:IsNull)
                //
                System.Linq.Enumerable.Single<Expression>(arrayInitializerExpression:Elements):AcceptVisitor(SELF)
            ELSE
                //
                SELF:PrintInitializerElements(arrayInitializerExpression:Elements)
            ENDIF
            SELF:EndNode(arrayInitializerExpression)
            
        VIRTUAL METHOD VisitArraySpecifier(arraySpecifier AS ArraySpecifier) AS VOID
            //
            SELF:StartNode(arraySpecifier)
            SELF:WriteToken(XSRoles.LBracket)
            FOREACH node AS CSharpTokenNode IN arraySpecifier:GetChildrenByRole<CSharpTokenNode>(XSRoles.Comma)
                //
                SELF:writer:WriteToken(XSRoles.Comma, ",")
            NEXT
            SELF:WriteToken(XSRoles.RBracket)
            SELF:EndNode(arraySpecifier)
            
        VIRTUAL METHOD VisitAsExpression(asExpression AS AsExpression) AS VOID
            //
            SELF:StartNode(asExpression)
            asExpression:Expression:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteKeyword(AsExpression.AsKeywordRole)
            SELF:Space(TRUE)
            asExpression:@@Type:AcceptVisitor(SELF)
            SELF:EndNode(asExpression)
            
        VIRTUAL METHOD VisitAssignmentExpression(assignmentExpression AS AssignmentExpression) AS VOID
            //
            SELF:StartNode(assignmentExpression)
            assignmentExpression:Left:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpaceAroundAssignment)
            SELF:WriteToken( XSharpTokenHelper.GetOperatorRole(assignmentExpression:Operator))
            SELF:Space(SELF:policy:SpaceAroundAssignment)
            assignmentExpression:Right:AcceptVisitor(SELF)
            SELF:EndNode(assignmentExpression)
            
        VIRTUAL METHOD VisitAttribute(attribute AS ICSharpCode.Decompiler.CSharp.Syntax.Attribute) AS VOID
            //
            SELF:StartNode(attribute)
            attribute:@@Type:AcceptVisitor(SELF)
            //IF ( attribute:Type:
            IF ((attribute:Arguments:Count != 0) .OR. ! attribute:GetChildByRole<CSharpTokenNode>(XSRoles.LPar):IsNull)
                //
                SELF:Space(SELF:policy:SpaceBeforeMethodCallParentheses)
                SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)attribute:Arguments , SELF:policy:SpaceWithinMethodCallParentheses)
            ENDIF
            SELF:EndNode(attribute)
            
        VIRTUAL METHOD VisitAttributeSection(attributeSection AS AttributeSection) AS VOID
            //
            SELF:StartNode(attributeSection)
            SELF:WriteToken(XSRoles.LBracket)
            IF (! String.IsNullOrEmpty(attributeSection:AttributeTarget))
                //
                SELF:WriteKeyword(attributeSection:AttributeTarget, XSRoles.Identifier)
                SELF:WriteToken(".")
                SELF:Space(TRUE)
            ENDIF
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)attributeSection:Attributes )
            SELF:WriteToken(XSRoles.RBracket)
            IF ((attributeSection:Parent IS ParameterDeclaration) .OR. (attributeSection:Parent IS TypeParameterDeclaration))
                //
                SELF:Space(TRUE)
            ELSE
                //
                SELF:WriteToken( XSRoles.Semicolon )
                SELF:NewLine()
            ENDIF
            SELF:EndNode(attributeSection)
            
        PRIVATE METHOD VisitBackreference(backreference AS Backreference) AS VOID
            //
            SELF:WriteKeyword("backreference", NULL)
            SELF:LPar()
            SELF:WriteIdentifier(backreference:ReferencedGroupName)
            SELF:RPar()
            
        VIRTUAL METHOD VisitBaseReferenceExpression(baseReferenceExpression AS BaseReferenceExpression) AS VOID
            //
            SELF:StartNode(baseReferenceExpression)
            SELF:WriteKeyword("SUPER", baseReferenceExpression:Role)
            SELF:EndNode(baseReferenceExpression)
            
        VIRTUAL METHOD VisitBinaryOperatorExpression(binaryOperatorExpression AS BinaryOperatorExpression) AS VOID
            LOCAL spaceAroundBitwiseOperator AS LOGIC
            LOCAL lGroup AS LOGIC
            //
            lGroup := ( binaryOperatorExpression:Operator == BinaryOperatorType.ConditionalAnd ) .OR. ( binaryOperatorExpression:Operator == BinaryOperatorType.ConditionalOr )
            //
            SELF:StartNode(binaryOperatorExpression)
            IF lGroup
                SELF:LPar()
            ENDIF
            binaryOperatorExpression:Left:AcceptVisitor(SELF)
            IF lGroup
                SELF:RPar()
            ENDIF
            SWITCH binaryOperatorExpression:Operator
            CASE BinaryOperatorType.BitwiseAnd
                CASE BinaryOperatorType.BitwiseOr
                CASE BinaryOperatorType.ExclusiveOr
                    //
                    spaceAroundBitwiseOperator := SELF:policy:SpaceAroundBitwiseOperator
                    
                CASE BinaryOperatorType.ConditionalAnd
                CASE BinaryOperatorType.ConditionalOr
                    //
                    spaceAroundBitwiseOperator := SELF:policy:SpaceAroundLogicalOperator
                    
                CASE BinaryOperatorType.GreaterThan
                CASE BinaryOperatorType.GreaterThanOrEqual
                CASE BinaryOperatorType.LessThan
                CASE BinaryOperatorType.LessThanOrEqual
                    //
                    spaceAroundBitwiseOperator := SELF:policy:SpaceAroundRelationalOperator
                    
                CASE BinaryOperatorType.Equality
                CASE BinaryOperatorType.InEquality
                    //
                    spaceAroundBitwiseOperator := SELF:policy:SpaceAroundEqualityOperator
                    
                CASE BinaryOperatorType.Add
                CASE BinaryOperatorType.Subtract 
                    //
                    spaceAroundBitwiseOperator := SELF:policy:SpaceAroundAdditiveOperator
                    
                CASE BinaryOperatorType.Multiply
                CASE BinaryOperatorType.Divide
                CASE BinaryOperatorType.Modulus
                    //
                    spaceAroundBitwiseOperator := SELF:policy:SpaceAroundMultiplicativeOperator
                    
                CASE BinaryOperatorType.ShiftLeft
                CASE BinaryOperatorType.ShiftRight
                    //
                    spaceAroundBitwiseOperator := SELF:policy:SpaceAroundShiftOperator
                    
                CASE BinaryOperatorType.NullCoalescing
                    //
                    spaceAroundBitwiseOperator := TRUE
                    
                OTHERWISE
                    //
                    THROW System.NotSupportedException{"Invalid value for BinaryOperatorType"}
                END SWITCH
            SELF:Space(spaceAroundBitwiseOperator)
            IF (binaryOperatorExpression:Operator == BinaryOperatorType.ConditionalAnd )
                SELF:WriteToken(".AND.")
            ELSEIF (binaryOperatorExpression:Operator == BinaryOperatorType.ConditionalOr )
                SELF:WriteToken(".OR.")
            ELSEIF (binaryOperatorExpression:Operator == BinaryOperatorType.NullCoalescing )
                SELF:WriteToken("DEFAULT")
            ELSE
                SELF:WriteToken(BinaryOperatorExpression.GetOperatorRole(binaryOperatorExpression:Operator))
            ENDIF
            SELF:Space(spaceAroundBitwiseOperator)
            IF lGroup
                SELF:LPar()
            ENDIF
            binaryOperatorExpression:Right:AcceptVisitor(SELF)
            IF lGroup
                SELF:RPar()
            ENDIF
            SELF:EndNode(binaryOperatorExpression)
            
        VIRTUAL METHOD VisitBlockStatement(blockStatement AS BlockStatement) AS VOID
            //
            SELF:WriteBlock(blockStatement, SELF:policy:StatementBraceStyle)
            SELF:NewLine()
            
        VIRTUAL METHOD VisitBreakStatement(breakStatement AS BreakStatement) AS VOID
            // In X#, Keyword is EXIT
            SELF:StartNode(breakStatement)
            SELF:WriteKeyword("EXIT", BreakStatement.BreakKeywordRole)
            SELF:NewLine()
            SELF:Semicolon()
            SELF:EndNode(breakStatement)
            
        VIRTUAL METHOD VisitCaseLabel(caseLabel AS CaseLabel) AS VOID
            //
            SELF:StartNode(caseLabel)
            IF (caseLabel:Expression:IsNull)
                //
                SELF:WriteKeyword("OTHERWISE")
            ELSE
                //
                SELF:WriteKeyword("CASE")
                SELF:Space(TRUE)
                caseLabel:Expression:AcceptVisitor(SELF)
            ENDIF
            //SELF:WriteToken(".")
            SELF:EndNode(caseLabel)
            
        VIRTUAL METHOD VisitCastExpression(castExpression AS CastExpression) AS VOID
            //
            SELF:StartNode(castExpression)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinCastParentheses)
            castExpression:@@Type:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinCastParentheses)
            SELF:RPar()
            SELF:Space(SELF:policy:SpaceAfterTypecast)
            castExpression:Expression:AcceptVisitor(SELF)
            SELF:EndNode(castExpression)
            
        VIRTUAL METHOD VisitCatchClause(catchClause AS CatchClause) AS VOID
            // 
            SELF:StartNode(catchClause)
            SELF:WriteKeyword("CATCH")
            IF (! catchClause:@@Type:IsNull)
                //
                SELF:Space(TRUE)
                IF (! String.IsNullOrEmpty(catchClause:VariableName))
                    //
                    SELF:WriteIdentifier(catchClause:VariableNameToken)
                    SELF:Space(TRUE)
                    SELF:WriteKeyword(AsExpression.AsKeywordRole)
                    SELF:Space(TRUE)
                ENDIF
                catchClause:@@Type:AcceptVisitor(SELF)
                SELF:Space(SELF:policy:SpacesWithinCatchParentheses)
            ENDIF
            // No Catch Condition in XSharp, but leave the code generation
            IF (! catchClause:Condition:IsNull)
                //
                SELF:Space(TRUE)
                SELF:WriteKeyword(CatchClause.WhenKeywordRole)
                SELF:Space(SELF:policy:SpaceBeforeIfParentheses)
                SELF:LPar()
                SELF:Space(SELF:policy:SpacesWithinIfParentheses)
                catchClause:Condition:AcceptVisitor(SELF)
                SELF:Space(SELF:policy:SpacesWithinIfParentheses)
                SELF:RPar()
            ENDIF
            SELF:WriteBlock(catchClause:Body, SELF:policy:StatementBraceStyle)
            SELF:EndNode(catchClause)
            
        VIRTUAL METHOD VisitCheckedExpression(checkedExpression AS CheckedExpression) AS VOID
            //
            SELF:StartNode(checkedExpression)
            SELF:WriteKeyword(CheckedExpression.CheckedKeywordRole)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinCheckedExpressionParantheses)
            checkedExpression:Expression:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinCheckedExpressionParantheses)
            SELF:RPar()
            SELF:EndNode(checkedExpression)
            
        VIRTUAL METHOD VisitCheckedStatement(checkedStatement AS CheckedStatement) AS VOID
            //
            SELF:StartNode(checkedStatement)
            SELF:WriteKeyword("BEGIN")
            SELF:Space(TRUE)
            SELF:WriteKeyword("CHECKED")
            SELF:Space(TRUE)
            SELF:NewLine()
            checkedStatement:Body:AcceptVisitor(SELF)
            SELF:WriteKeyword("END")
            SELF:Space(TRUE)
            SELF:WriteKeyword("CHECKED")
            SELF:EndNode(checkedStatement)
            
        PRIVATE METHOD VisitChoice(choice AS Choice) AS VOID
            //
            SELF:WriteKeyword("choice", NULL)
            SELF:Space(TRUE)
            SELF:LPar()
            SELF:NewLine()
            SELF:writer:Indent()
            FOREACH node AS INode IN (System.Collections.Generic.IEnumerable<INode>)choice 
                //
                SELF:VisitNodeInPattern(node)
                IF (node != System.Linq.Enumerable.Last<INode>(choice))
                    //
                    SELF:WriteToken(XSRoles.Comma)
                ENDIF
                SELF:NewLine()
            NEXT
            SELF:writer:Unindent()
            SELF:RPar()
            
        VIRTUAL METHOD VisitComment(comment AS Comment) AS VOID
            //
            SELF:writer:StartNode(comment)
            SELF:writer:WriteComment(comment:CommentType, comment:Content)
            SELF:writer:EndNode(comment)
            
        VIRTUAL METHOD VisitComposedType(composedType AS ComposedType) AS VOID
            LOCAL i AS LONG
            //
            SELF:StartNode(composedType)
            IF (composedType:HasRefSpecifier)
                //
                SELF:WriteKeyword(ComposedType.RefRole)
            ENDIF
            composedType:BaseType:AcceptVisitor(SELF)
            IF (composedType:HasNullableSpecifier)
                //
                SELF:WriteToken(ComposedType.NullableRole)
            ENDIF
            i := 0
            WHILE ((i < composedType:PointerRank))
                //
                SELF:WriteToken(ComposedType.PointerRole)
                i++
            ENDDO
            FOREACH specifier AS ArraySpecifier IN composedType:ArraySpecifiers
                //
                specifier:AcceptVisitor(SELF)
            NEXT
            SELF:EndNode(composedType)
            
        VIRTUAL METHOD VisitConditionalExpression(conditionalExpression AS ConditionalExpression) AS VOID
            //
            SELF:StartNode(conditionalExpression)
            SELF:WriteToken("IIF" )
            SELF:LPar()
            conditionalExpression:Condition:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpaceBeforeConditionalOperatorCondition)
            SELF:WriteToken("," )
            SELF:Space(SELF:policy:SpaceAfterConditionalOperatorCondition)
            conditionalExpression:TrueExpression:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpaceBeforeConditionalOperatorSeparator)
            SELF:WriteToken("," )
            SELF:Space(SELF:policy:SpaceAfterConditionalOperatorSeparator)
            conditionalExpression:FalseExpression:AcceptVisitor(SELF)
            SELF:RPar()
            SELF:EndNode(conditionalExpression)
            
        VIRTUAL METHOD VisitConstraint(constraint AS Constraint) AS VOID
            //
            SELF:StartNode(constraint)
            SELF:Space(TRUE)
            SELF:WriteKeyword(XSRoles.WhereKeyword)
            constraint:TypeParameter:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteToken(".")
            SELF:Space(TRUE)
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)constraint:BaseTypes )
            SELF:EndNode(constraint)
            
        VIRTUAL METHOD VisitConstructorDeclaration(constructorDeclaration AS ConstructorDeclaration) AS VOID
            LOCAL parent AS TypeDeclaration
            //
            SELF:StartNode(constructorDeclaration)
            SELF:WriteAttributes(constructorDeclaration:Attributes)
            SELF:WriteModifiers(constructorDeclaration:ModifierTokens)
            parent := constructorDeclaration:Parent ASTYPE TypeDeclaration
            IF ((parent != NULL) .AND. (parent:Name != constructorDeclaration:Name))
                //
                SELF:WriteIdentifier((Identifier)parent:NameToken:Clone() )
            ELSE
                //
                SELF:WriteKeyword("CONSTRUCTOR")
            ENDIF
            SELF:Space(SELF:policy:SpaceBeforeConstructorDeclarationParentheses)
            SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)constructorDeclaration:Parameters , SELF:policy:SpaceWithinMethodDeclarationParentheses)
            IF (! constructorDeclaration:Initializer:IsNull)
                // Continue on Next Line
                SELF:WriteToken(XSRoles.Semicolon)
                SELF:NewLine()
                SELF:writer:Indent()
                constructorDeclaration:Initializer:AcceptVisitor(SELF)
                SELF:writer:Unindent()
            ENDIF
            // Save the current/Declaring type
            SELF:currentType := SELF:GetElementType( constructorDeclaration )
            //
            SELF:WriteMethodBody(constructorDeclaration:Body, SELF:policy:ConstructorBraceStyle)
            SELF:currentType := NULL
            SELF:EndNode(constructorDeclaration)
            
        VIRTUAL METHOD VisitConstructorInitializer(constructorInitializer AS ConstructorInitializer) AS VOID
            //
            SELF:StartNode(constructorInitializer)
            SELF:Space(TRUE)
            IF (constructorInitializer:ConstructorInitializerType == ConstructorInitializerType.This)
                //
                SELF:WriteKeyword("SELF")
            ELSE
                //
                SELF:WriteKeyword(ConstructorInitializer.BaseKeywordRole)
            ENDIF
            SELF:Space(SELF:policy:SpaceBeforeMethodCallParentheses)
            SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)constructorInitializer:Arguments , SELF:policy:SpaceWithinMethodCallParentheses)
            SELF:EndNode(constructorInitializer)
            
        VIRTUAL METHOD VisitContinueStatement(continueStatement AS ContinueStatement) AS VOID
            //
            SELF:StartNode(continueStatement)
            SELF:WriteKeyword("continue", ContinueStatement.ContinueKeywordRole)
            SELF:Semicolon()
            SELF:EndNode(continueStatement)
            
        VIRTUAL METHOD VisitCSharpTokenNode(cSharpTokenNode AS CSharpTokenNode) AS VOID
            LOCAL token AS CSharpModifierToken
            //
            token := (CSharpModifierToken)(cSharpTokenNode)
            IF (token == NULL)
                //
                THROW System.NotSupportedException{"Should never visit individual tokens"}
            ENDIF
            SELF:WriteKeyword(CSharpModifierToken.GetModifierName(token:Modifier), cSharpTokenNode:Role)
            
        VIRTUAL METHOD VisitCustomEventDeclaration(customEventDeclaration AS CustomEventDeclaration) AS VOID
            //
            SELF:StartNode(customEventDeclaration)
            SELF:WriteAttributes(customEventDeclaration:Attributes)
            SELF:WriteModifiers(customEventDeclaration:ModifierTokens)
            SELF:WriteKeyword(CustomEventDeclaration.EventKeywordRole)
            customEventDeclaration:ReturnType:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WritePrivateImplementationType(customEventDeclaration:PrivateImplementationType)
            SELF:WriteIdentifier(customEventDeclaration:NameToken)
            SELF:OpenBrace(SELF:policy:EventBraceStyle)
            FOREACH node AS AstNode IN customEventDeclaration:Children
                //
                IF ((node:Role == CustomEventDeclaration.AddAccessorRole) .OR. (node:Role == CustomEventDeclaration.RemoveAccessorRole))
                    //
                    node:AcceptVisitor(SELF)
                ENDIF
            NEXT
            SELF:CloseBrace(SELF:policy:EventBraceStyle)
            SELF:NewLine()
            SELF:EndNode(customEventDeclaration)
            
        VIRTUAL METHOD VisitDefaultValueExpression(defaultValueExpression AS DefaultValueExpression) AS VOID
            //
            SELF:StartNode(defaultValueExpression)
            SELF:WriteKeyword(DefaultValueExpression.DefaultKeywordRole)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinTypeOfParentheses)
            defaultValueExpression:@@Type:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinTypeOfParentheses)
            SELF:RPar()
            SELF:EndNode(defaultValueExpression)
            
        VIRTUAL METHOD VisitDelegateDeclaration(delegateDeclaration AS DelegateDeclaration) AS VOID
            //
            SELF:StartNode(delegateDeclaration)
            SELF:WriteAttributes(delegateDeclaration:Attributes)
            SELF:WriteModifiers(delegateDeclaration:ModifierTokens)
            SELF:WriteKeyword(XSRoles.DelegateKeyword)
            delegateDeclaration:ReturnType:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteIdentifier(delegateDeclaration:NameToken)
            SELF:WriteTypeParameters(delegateDeclaration:TypeParameters)
            SELF:Space(SELF:policy:SpaceBeforeDelegateDeclarationParentheses)
            SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)delegateDeclaration:Parameters , SELF:policy:SpaceWithinMethodDeclarationParentheses)
            FOREACH constraint AS Constraint IN delegateDeclaration:Constraints
                //
                constraint:AcceptVisitor(SELF)
            NEXT
            SELF:Semicolon()
            SELF:EndNode(delegateDeclaration)
            
        VIRTUAL METHOD VisitDestructorDeclaration(destructorDeclaration AS DestructorDeclaration) AS VOID
            LOCAL parent AS TypeDeclaration
            //
            SELF:StartNode(destructorDeclaration)
            SELF:WriteAttributes(destructorDeclaration:Attributes)
            SELF:WriteModifiers(destructorDeclaration:ModifierTokens)
            IF (System.Linq.Enumerable.Any<CSharpModifierToken>(destructorDeclaration:ModifierTokens))
                //
                SELF:Space(TRUE)
            ENDIF
            //SELF:WriteToken(DestructorDeclaration.TildeRole)
            parent := destructorDeclaration:Parent ASTYPE TypeDeclaration
            IF ((parent != NULL) .AND. (parent:Name != destructorDeclaration:Name))
                //
                SELF:WriteIdentifier((Identifier)parent:NameToken:Clone() )
            ELSE
                //
                SELF:WriteIdentifier("DESTRUCTOR")
            ENDIF
            SELF:Space(SELF:policy:SpaceBeforeConstructorDeclarationParentheses)
            SELF:LPar()
            SELF:RPar()
            SELF:WriteMethodBody(destructorDeclaration:Body, SELF:policy:DestructorBraceStyle)
            SELF:EndNode(destructorDeclaration)
            
        VIRTUAL METHOD VisitDirectionExpression(directionExpression AS DirectionExpression) AS VOID
            LOCAL fieldDirection AS FieldDirection
            //
            SELF:StartNode(directionExpression)
            fieldDirection := directionExpression:FieldDirection
            SWITCH (fieldDirection)
                CASE ( FieldDirection.Out)
                    SELF:WriteKeyword("OUT")
                CASE ( FieldDirection.Ref)
                    SELF:WriteKeyword("REF")
                OTHERWISE
                    THROW System.NotSupportedException{"Invalid value for FieldDirection"}
            END 
            SELF:Space(TRUE)
            directionExpression:Expression:AcceptVisitor(SELF)
            SELF:EndNode(directionExpression)
            
        VIRTUAL METHOD VisitDocumentationReference(documentationReference AS DocumentationReference) AS VOID
            LOCAL symbolKind AS SymbolKind
            LOCAL operatorType AS OperatorType
            //
            SELF:StartNode(documentationReference)
            IF (! documentationReference:DeclaringType:IsNull)
                //
                documentationReference:DeclaringType:AcceptVisitor(SELF)
                IF (documentationReference:SymbolKind != SymbolKind.TypeDefinition)
                    //
                    SELF:WriteToken(".")
                ENDIF
            ENDIF
            symbolKind := documentationReference:SymbolKind
            IF (symbolKind != SymbolKind.TypeDefinition)
                //
                IF (symbolKind == SymbolKind.Indexer)
                    //
                    SELF:WriteKeyword(IndexerDeclaration.ThisKeywordRole)
                ELSE
                    //
                    IF (symbolKind == SymbolKind.Operator)
                        //
                        operatorType := documentationReference:OperatorType
                        SWITCH operatorType
                            CASE OperatorType.Explicit
                                //
                                SELF:WriteKeyword(OperatorDeclaration.ExplicitRole)
                                
                            CASE OperatorType.Implicit
                                //
                                SELF:WriteKeyword(OperatorDeclaration.ImplicitRole)
                                
                        END SWITCH
                        SELF:WriteKeyword(OperatorDeclaration.OperatorKeywordRole)
                        SELF:Space(TRUE)
                        
                        SWITCH operatorType
                            CASE OperatorType.Explicit
                            CASE OperatorType.Implicit
                                //
                                documentationReference:ConversionOperatorReturnType:AcceptVisitor(SELF)
                                
                            OTHERWISE
                                //
                                SELF:WriteToken(OperatorDeclaration.GetToken(operatorType), OperatorDeclaration.GetRole(operatorType))
                                
                        END SWITCH
                    ELSE
                        //
                        SELF:WriteIdentifier(documentationReference:GetChildByRole<Identifier>(XSRoles.Identifier))
                    ENDIF
                ENDIF
            ENDIF
            SELF:WriteTypeArguments(documentationReference:TypeArguments)
            IF (documentationReference:HasParameterList)
                //
                SELF:Space(SELF:policy:SpaceBeforeMethodDeclarationParentheses)
                IF (documentationReference:SymbolKind == SymbolKind.Indexer)
                    //
                    SELF:WriteCommaSeparatedListInBrackets(documentationReference:Parameters, SELF:policy:SpaceWithinMethodDeclarationParentheses)
                ELSE
                    //
                    SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)documentationReference:Parameters , SELF:policy:SpaceWithinMethodDeclarationParentheses)
                ENDIF
            ENDIF
            SELF:EndNode(documentationReference)
            
        VIRTUAL METHOD VisitDoWhileStatement(doWhileStatement AS DoWhileStatement) AS VOID
            //
            SELF:StartNode(doWhileStatement)
            SELF:WriteKeyword("REPEAT")
            SELF:WriteEmbeddedStatement(doWhileStatement:EmbeddedStatement, SELF:policy:WhileNewLinePlacement)
            SELF:WriteKeyword("UNTIL")
            SELF:Space(SELF:policy:SpaceBeforeWhileParentheses)
            SELF:WriteKeyword("!")
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinWhileParentheses)
            doWhileStatement:Condition:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinWhileParentheses)
            SELF:RPar()
            SELF:NewLine()
            SELF:Semicolon()
            SELF:EndNode(doWhileStatement)
            
        VIRTUAL METHOD VisitEmptyStatement(emptyStatement AS EmptyStatement) AS VOID
            //
            SELF:StartNode(emptyStatement)
            SELF:WriteKeyword("NOP")
            SELF:Semicolon()
            SELF:EndNode(emptyStatement)
            
        VIRTUAL METHOD VisitEnumMemberDeclaration(enumMemberDeclaration AS EnumMemberDeclaration) AS VOID
            //
            SELF:StartNode(enumMemberDeclaration)
            SELF:WriteAttributes(enumMemberDeclaration:Attributes)
            SELF:WriteModifiers(enumMemberDeclaration:ModifierTokens)
            SELF:WriteKeyword( "MEMBER" )
            SELF:Space(TRUE)
            SELF:WriteIdentifier(enumMemberDeclaration:NameToken)
            IF (! enumMemberDeclaration:Initializer:IsNull)
                //
                SELF:Space(SELF:policy:SpaceAroundAssignment)
                SELF:WriteToken(":=")
                SELF:Space(SELF:policy:SpaceAroundAssignment)
                enumMemberDeclaration:Initializer:AcceptVisitor(SELF)
            ENDIF
            SELF:EndNode(enumMemberDeclaration)
            
        VIRTUAL METHOD VisitEventDeclaration(eventDeclaration AS EventDeclaration) AS VOID
            //
            SELF:StartNode(eventDeclaration)
            SELF:WriteAttributes(eventDeclaration:Attributes)
            SELF:WriteModifiers(eventDeclaration:ModifierTokens)
            SELF:WriteKeyword(EventDeclaration.EventKeywordRole)
            eventDeclaration:ReturnType:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)eventDeclaration:Variables )
            SELF:Semicolon()
            SELF:EndNode(eventDeclaration)
            
        VIRTUAL METHOD VisitExpressionStatement(expressionStatement AS ExpressionStatement) AS VOID
            //
            SELF:StartNode(expressionStatement)
            expressionStatement:Expression:AcceptVisitor(SELF)
            SELF:NewLine()
            SELF:EndNode(expressionStatement)
            
        VIRTUAL METHOD VisitExternAliasDeclaration(externAliasDeclaration AS ExternAliasDeclaration) AS VOID
            //
            SELF:StartNode(externAliasDeclaration)
            SELF:WriteKeyword(XSRoles.ExternKeyword)
            SELF:Space(TRUE)
            SELF:WriteKeyword(XSRoles.AliasKeyword)
            SELF:Space(TRUE)
            SELF:WriteIdentifier(externAliasDeclaration:NameToken)
            SELF:Semicolon()
            SELF:EndNode(externAliasDeclaration)
            
        VIRTUAL METHOD VisitFieldDeclaration(fieldDeclaration AS FieldDeclaration) AS VOID
            //
            SELF:StartNode(fieldDeclaration)
            SELF:WriteAttributes(fieldDeclaration:Attributes)
            SELF:WriteModifiers(fieldDeclaration:ModifierTokens)
            SELF:Space(TRUE)
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)fieldDeclaration:Variables )
            SELF:Space(TRUE)
            SELF:WriteKeyword("AS" )
            SELF:Space(TRUE)
            fieldDeclaration:ReturnType:AcceptVisitor(SELF)
            SELF:Semicolon()
            SELF:EndNode(fieldDeclaration)
            
        VIRTUAL METHOD VisitFixedFieldDeclaration(fixedFieldDeclaration AS FixedFieldDeclaration) AS VOID
            //
            SELF:StartNode(fixedFieldDeclaration)
            SELF:WriteAttributes(fixedFieldDeclaration:Attributes)
            SELF:WriteModifiers(fixedFieldDeclaration:ModifierTokens)
            SELF:WriteKeyword(FixedFieldDeclaration.FixedKeywordRole)
            SELF:Space(TRUE)
            fixedFieldDeclaration:ReturnType:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)fixedFieldDeclaration:Variables )
            SELF:Semicolon()
            SELF:EndNode(fixedFieldDeclaration)
            
        VIRTUAL METHOD VisitFixedStatement(fixedStatement AS FixedStatement) AS VOID
            //
            SELF:StartNode(fixedStatement)
            SELF:WriteKeyword(FixedStatement.FixedKeywordRole)
            SELF:Space(SELF:policy:SpaceBeforeUsingParentheses)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinUsingParentheses)
            fixedStatement:@@Type:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)fixedStatement:Variables )
            SELF:Space(SELF:policy:SpacesWithinUsingParentheses)
            SELF:RPar()
            SELF:WriteEmbeddedStatement(fixedStatement:EmbeddedStatement, NewLinePlacement.NewLine)
            SELF:EndNode(fixedStatement)
            
        VIRTUAL METHOD VisitFixedVariableInitializer(fixedVariableInitializer AS FixedVariableInitializer) AS VOID
            //
            SELF:StartNode(fixedVariableInitializer)
            SELF:WriteIdentifier(fixedVariableInitializer:NameToken)
            IF (! fixedVariableInitializer:CountExpression:IsNull)
                //
                SELF:WriteToken(XSRoles.LBracket)
                SELF:Space(SELF:policy:SpacesWithinBrackets)
                fixedVariableInitializer:CountExpression:AcceptVisitor(SELF)
                SELF:Space(SELF:policy:SpacesWithinBrackets)
                SELF:WriteToken(XSRoles.RBracket)
            ENDIF
            SELF:EndNode(fixedVariableInitializer)
            
        VIRTUAL METHOD VisitForeachStatement(foreachStatement AS ForeachStatement) AS VOID
            //
            SELF:StartNode(foreachStatement)
            SELF:WriteKeyword("FOREACH")
            SELF:Space()
            SELF:WriteIdentifier(foreachStatement:VariableNameToken)
            SELF:Space()
            SELF:WriteKeyword("AS")
            SELF:Space()
            foreachStatement:VariableType:AcceptVisitor(SELF)
            SELF:Space()
            SELF:WriteKeyword("IN")
            SELF:Space()
            foreachStatement:InExpression:AcceptVisitor(SELF)
            SELF:Space()
            SELF:WriteEmbeddedStatement(foreachStatement:EmbeddedStatement, NewLinePlacement.NewLine)
            SELF:WriteKeyword("NEXT")
            SELF:NewLine()
            SELF:EndNode(foreachStatement)
            
        VIRTUAL METHOD VisitForStatement(forStatement AS ForStatement) AS VOID
            //
            //            SELF:StartNode(forStatement)
            //            SELF:WriteKeyword("FOR")
            //            SELF:Space()
            //            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)forStatement:Initializers )
            //            SELF:Space()
            //            SELF:WriteKeyword("TO")
            //            SELF:Space()
            //            forStatement:Condition:AcceptVisitor(SELF)
            //            IF (System.Linq.Enumerable.Any<Statement>(forStatement:Iterators))
            //                //
            //                SELF:Space()
            //                SELF:WriteKeyword("STEP")
            //                SELF:Space()
            //                SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)forStatement:Iterators )
            //            ENDIF
            //            SELF:WriteEmbeddedStatement(forStatement:EmbeddedStatement, NewLinePlacement.NewLine)
            //            SELF:WriteKeyword("NEXT")
            //            SELF:NewLine()
            //            SELF:EndNode(forStatement)
            SELF:StartNode(forStatement)
            SELF:WriteSingleCommment( "Init" )
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)forStatement:Initializers )
            IF ( !SELF:isAtStartOfLine )
                SELF:NewLine()
            ENDIF
            //
            SELF:WriteKeyword("WHILE")
            SELF:Space()
            forStatement:Condition:AcceptVisitor(SELF)
            //
            SELF:WriteEmbeddedStatement(forStatement:EmbeddedStatement, NewLinePlacement.NewLine)
            //
            SELF:writer:Indent()
            SELF:WriteSingleCommment( "Iterators" )
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)forStatement:Iterators )
            SELF:writer:Unindent()
            SELF:WriteKeyword("ENDDO")
            SELF:NewLine()
            SELF:EndNode(forStatement)
            
        VIRTUAL METHOD VisitGotoCaseStatement(gotoCaseStatement AS GotoCaseStatement) AS VOID
            //
            SELF:StartNode(gotoCaseStatement)
            SELF:WriteKeyword(GotoCaseStatement.GotoKeywordRole)
            SELF:WriteKeyword(GotoCaseStatement.CaseKeywordRole)
            SELF:Space(TRUE)
            gotoCaseStatement:LabelExpression:AcceptVisitor(SELF)
            SELF:Semicolon()
            SELF:EndNode(gotoCaseStatement)
            
        VIRTUAL METHOD VisitGotoDefaultStatement(gotoDefaultStatement AS GotoDefaultStatement) AS VOID
            //
            SELF:StartNode(gotoDefaultStatement)
            SELF:WriteKeyword(GotoDefaultStatement.GotoKeywordRole)
            SELF:WriteKeyword(GotoDefaultStatement.DefaultKeywordRole)
            SELF:Semicolon()
            SELF:EndNode(gotoDefaultStatement)
            
        VIRTUAL METHOD VisitGotoStatement(gotoStatement AS GotoStatement) AS VOID
            //
            SELF:StartNode(gotoStatement)
            SELF:WriteKeyword(GotoStatement.GotoKeywordRole)
            SELF:WriteIdentifier(gotoStatement:GetChildByRole<Identifier>(XSRoles.Identifier))
            SELF:Semicolon()
            SELF:EndNode(gotoStatement)
            
        VIRTUAL METHOD VisitIdentifier(identifier AS Identifier) AS VOID
            //
            SELF:WriteIdentifier(identifier)
            
        VIRTUAL METHOD VisitIdentifierExpression(identifierExpression AS IdentifierExpression) AS VOID
            //
            SELF:StartNode(identifierExpression)
            //          
            SELF:Prefix( identifierExpression )
            //
            SELF:WriteIdentifier(identifierExpression:IdentifierToken)
            SELF:WriteTypeArguments(identifierExpression:TypeArguments)
            SELF:EndNode(identifierExpression)
            
        PRIVATE METHOD VisitIdentifierExpressionBackreference(identifierExpressionBackreference AS IdentifierExpressionBackreference) AS VOID
            //
            SELF:WriteKeyword("identifierBackreference", NULL)
            SELF:LPar()
            SELF:WriteIdentifier(identifierExpressionBackreference:ReferencedGroupName)
            SELF:RPar()
            
        VIRTUAL METHOD VisitIfElseStatement(ifElseStatement AS IfElseStatement) AS VOID
            //
            SELF:StartNode(ifElseStatement)
            //SELF:WriteKeyword(IfElseStatement.IfKeywordRole)
            SELF:WriteKeyword("IF")
            SELF:Space(SELF:policy:SpaceBeforeIfParentheses)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinIfParentheses)
            ifElseStatement:Condition:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinIfParentheses)
            SELF:RPar()
            IF (ifElseStatement:FalseStatement:IsNull)
                //
                SELF:WriteEmbeddedStatement(ifElseStatement:TrueStatement, NewLinePlacement.SameLine)
            ELSE
                //
                SELF:WriteEmbeddedStatement(ifElseStatement:TrueStatement, SELF:policy:ElseNewLinePlacement)
                //SELF:WriteKeyword(IfElseStatement.ElseKeywordRole)
                SELF:WriteKeyword("ELSE")
                IF ((ifElseStatement:FalseStatement IS IfElseStatement))
                    //
                    SELF:NewLine()
                    SELF:writer:Indent()
                    ifElseStatement:FalseStatement:AcceptVisitor(SELF)
                    SELF:writer:Unindent()
                ELSE
                    //
                    SELF:WriteEmbeddedStatement(ifElseStatement:FalseStatement, NewLinePlacement.SameLine)
                ENDIF
            ENDIF
            SELF:WriteKeyword("ENDIF")
            SELF:NewLine()
            SELF:EndNode(ifElseStatement)
            
        VIRTUAL METHOD VisitIndexerDeclaration(indexerDeclaration AS IndexerDeclaration) AS VOID
            //
            SELF:StartNode(indexerDeclaration)
            SELF:WriteAttributes(indexerDeclaration:Attributes)
            SELF:WriteModifiers(indexerDeclaration:ModifierTokens)
            SELF:WriteKeyword("PROPERTY" )
            SELF:Space(TRUE)
            SELF:WritePrivateImplementationType(indexerDeclaration:PrivateImplementationType)
            SELF:WriteKeyword("SELF")
            SELF:Space(SELF:policy:SpaceBeforeMethodDeclarationParentheses)
            SELF:WriteCommaSeparatedListInBrackets(indexerDeclaration:Parameters, SELF:policy:SpaceWithinMethodDeclarationParentheses)
            SELF:Space(TRUE)
            SELF:WriteKeyword("AS", NULL )
            SELF:Space(TRUE)
            indexerDeclaration:ReturnType:AcceptVisitor(SELF)
            SELF:OpenBrace(SELF:policy:PropertyBraceStyle)
            FOREACH node AS AstNode IN indexerDeclaration:Children
                //
                IF ((node:Role == IndexerDeclaration.GetterRole) .OR. (node:Role == IndexerDeclaration.SetterRole))
                    //
                    node:AcceptVisitor(SELF)
                ENDIF
            NEXT
            SELF:WriteKeyword("END" )
            SELF:Space(TRUE)
            SELF:WriteKeyword("PROPERTY" )
            SELF:CloseBrace(SELF:policy:PropertyBraceStyle)
            SELF:NewLine()
            SELF:EndNode(indexerDeclaration)
            
        VIRTUAL METHOD VisitIndexerExpression(indexerExpression AS IndexerExpression) AS VOID
            //
            SELF:StartNode(indexerExpression)
            indexerExpression:Target:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpaceBeforeMethodCallParentheses)
            SELF:WriteCommaSeparatedListInBrackets(indexerExpression:Arguments)
            SELF:EndNode(indexerExpression)
            
        VIRTUAL METHOD VisitInterpolatedStringExpression(interpolatedStringExpression AS InterpolatedStringExpression) AS VOID
            //
            SELF:StartNode(interpolatedStringExpression)
            SELF:writer:WriteToken(InterpolatedStringExpression.OpenQuote, "$"+chr(34))
            FOREACH content AS InterpolatedStringContent IN interpolatedStringExpression:Content
                //
                content:AcceptVisitor(SELF)
            NEXT
            SELF:writer:WriteToken(InterpolatedStringExpression.CloseQuote, chr(34))
            SELF:isAfterSpace := FALSE
            SELF:EndNode(interpolatedStringExpression)
            
        VIRTUAL METHOD VisitInterpolatedStringText(interpolatedStringText AS InterpolatedStringText) AS VOID
            //
            SELF:StartNode(interpolatedStringText)
            SELF:writer:WritePrimitiveValue("", TextWriterTokenWriter.ConvertString(interpolatedStringText:Text))
            SELF:EndNode(interpolatedStringText)
            
        VIRTUAL METHOD VisitInterpolation(interpolation AS Interpolation) AS VOID
            //
            SELF:StartNode(interpolation)
            SELF:writer:WriteToken(Interpolation.LBrace, "{")
            interpolation:Expression:AcceptVisitor(SELF)
            IF (interpolation:Suffix != NULL)
                //
                SELF:writer:WriteToken(NULL, ":")
                SELF:writer:WritePrimitiveValue("", interpolation:Suffix)
            ENDIF
            SELF:writer:WriteToken(Interpolation.RBrace, "}")
            SELF:EndNode(interpolation)
            
        VIRTUAL METHOD VisitInvocationExpression(invocationExpression AS InvocationExpression) AS VOID
            LOCAL expression AS MemberReferenceExpression
            //
            SELF:StartNode(invocationExpression)
            //           
            SELF:Prefix( invocationExpression )
            //
            invocationExpression:Target:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpaceBeforeMethodCallParentheses)
            SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)invocationExpression:Arguments , SELF:policy:SpaceWithinMethodCallParentheses)
            IF (! (invocationExpression:Parent IS MemberReferenceExpression) ) 
                expression := invocationExpression:Target ASTYPE MemberReferenceExpression
                IF ( expression != NULL)
                    IF (SELF:GetCallChainLengthLimited(expression) >= 3)
                        //
                        SELF:writer:Unindent()
                    ENDIF
                ENDIF
            ENDIF
            SELF:EndNode(invocationExpression)
            
        VIRTUAL METHOD VisitIsExpression(isExpression AS IsExpression) AS VOID
            //
            SELF:StartNode(isExpression)
            isExpression:Expression:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteKeyword("ASTYPE")
            SELF:Space(TRUE)
            isExpression:@@Type:AcceptVisitor(SELF)
            SELF:EndNode(isExpression)
            
        VIRTUAL METHOD VisitLabelStatement(labelStatement AS LabelStatement) AS VOID
            LOCAL flag AS LOGIC
            LOCAL node AS AstNode
            //
            SELF:StartNode(labelStatement)
            SELF:WriteIdentifier(labelStatement:GetChildByRole<Identifier>(XSRoles.Identifier))
            SELF:WriteToken(".")
            flag := FALSE
            node := labelStatement:NextSibling
            WHILE ((node != NULL))
                //
                IF (node:Role == labelStatement:Role)
                    //
                    flag := TRUE
                ENDIF
                node := node:NextSibling
            ENDDO
            IF (! flag)
                //
                SELF:WriteToken(XSRoles.Semicolon)
            ENDIF
            SELF:NewLine()
            SELF:EndNode(labelStatement)
            
        VIRTUAL METHOD VisitLambdaExpression(lambdaExpression AS LambdaExpression) AS VOID
            //
            SELF:StartNode(lambdaExpression)
            IF (lambdaExpression:IsAsync)
                //
                SELF:WriteKeyword(LambdaExpression.AsyncModifierRole)
                SELF:Space(TRUE)
            ENDIF
            SELF:WriteToken( "{" )
            IF (SELF:LambdaNeedsParenthesis(lambdaExpression))
                SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)lambdaExpression:Parameters)
            ELSE
                System.Linq.Enumerable.Single<ParameterDeclaration>(lambdaExpression:Parameters):AcceptVisitor(SELF)
            ENDIF
            SELF:Space(TRUE)
            SELF:WriteToken(XSRoles.Arrow)
            IF ((lambdaExpression:Body IS BlockStatement))
                //
                SELF:WriteBlock((BlockStatement)lambdaExpression:Body , SELF:policy:AnonymousMethodBraceStyle)
            ELSE
                //
                SELF:Space(TRUE)
                lambdaExpression:Body:AcceptVisitor(SELF)
            ENDIF
            SELF:WriteToken( "}" )
            SELF:EndNode(lambdaExpression)
            
        VIRTUAL METHOD VisitLockStatement(lockStatement AS LockStatement) AS VOID
            //
            SELF:StartNode(lockStatement)
            SELF:WriteKeyword("BEGIN")
            SELF:Space(TRUE)
            SELF:WriteKeyword("LOCK")
            SELF:Space(TRUE)
            lockStatement:Expression:AcceptVisitor(SELF)
            SELF:NewLine()
            SELF:WriteEmbeddedStatement(lockStatement:EmbeddedStatement, NewLinePlacement.NewLine)
            SELF:WriteKeyword("END")
            SELF:Space(TRUE)
            SELF:WriteKeyword("LOCK")
            SELF:EndNode(lockStatement)
            
        VIRTUAL METHOD VisitMemberReferenceExpression(memberReferenceExpression AS MemberReferenceExpression) AS VOID
            //
            SELF:StartNode(memberReferenceExpression)
            memberReferenceExpression:Target:AcceptVisitor(SELF)
            SELF:InsertNewLineWhenInMethodCallChain(memberReferenceExpression)
            IF ( ( memberReferenceExpression:Target ASTYPE TypeReferenceExpression ) != NULL )
                SELF:WriteToken("." )
            ELSE
                SELF:WriteToken(":")
            ENDIF
            SELF:WriteIdentifier(memberReferenceExpression:MemberNameToken)
            SELF:WriteTypeArguments(memberReferenceExpression:TypeArguments)
            SELF:EndNode(memberReferenceExpression)
            
        VIRTUAL METHOD VisitMemberType(memberType AS MemberType) AS VOID
            //
            SELF:StartNode(memberType)
            memberType:Target:AcceptVisitor(SELF)
            IF (memberType:IsDoubleColon)
                //
                SELF:WriteToken("::")
            ELSE
                //
                SELF:WriteToken(".")
            ENDIF
            SELF:WriteIdentifier(memberType:MemberNameToken)
            SELF:WriteTypeArguments(memberType:TypeArguments)
            SELF:EndNode(memberType)
            
        VIRTUAL METHOD VisitMethodDeclaration(methodDeclaration AS MethodDeclaration) AS VOID
            // Reset Method Call Type
            SELF:isClipper := FALSE
            //
            SELF:StartNode(methodDeclaration)
            SELF:inMethodAttributes := ClipperState.Attribute
            SELF:paramsList := List<STRING>{}
            SELF:WriteAttributes(methodDeclaration:Attributes)
            SELF:inMethodAttributes := ClipperState.Code
            SELF:WriteModifiers(methodDeclaration:ModifierTokens)
            SELF:Space(TRUE)
            SELF:WritePrivateImplementationType(methodDeclaration:PrivateImplementationType)
            SELF:Space(TRUE)
            //
            SELF:WriteKeyword("METHOD", NULL )
            SELF:Space(TRUE)
            //
            SELF:WriteIdentifier(methodDeclaration:NameToken)
            SELF:WriteTypeParameters(methodDeclaration:TypeParameters)
            SELF:Space(SELF:policy:SpaceBeforeMethodDeclarationParentheses)
            SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)methodDeclaration:Parameters , SELF:policy:SpaceWithinMethodDeclarationParentheses)
            FOREACH constraint AS Constraint IN methodDeclaration:Constraints
                //
                constraint:AcceptVisitor(SELF)
            NEXT
            //
            SELF:Space(TRUE)
            SELF:WriteKeyword("AS", NULL )
            SELF:Space(TRUE)
            SELF:inMethodAttributes := ClipperState.ReturnType
            methodDeclaration:ReturnType:AcceptVisitor(SELF)
            //
            SELF:inMethodAttributes := ClipperState.Code
            IF ( SELF:isClipper )
                SELF:paramsList:Insert( 0, methodDeclaration:NameToken:Name)
            ENDIF
            // Save the current/Declaring type
            SELF:currentType := SELF:GetElementType( methodDeclaration )
            //
            SELF:WriteMethodBody(methodDeclaration:Body, SELF:policy:MethodBraceStyle)
            SELF:currentType := NULL
            SELF:inMethodAttributes := ClipperState.None
            SELF:EndNode(methodDeclaration)
            
        VIRTUAL METHOD VisitNamedArgumentExpression(namedArgumentExpression AS NamedArgumentExpression) AS VOID
            //
            SELF:StartNode(namedArgumentExpression)
            SELF:WriteIdentifier(namedArgumentExpression:NameToken)
            SELF:WriteToken(":")
            SELF:Space(TRUE)
            namedArgumentExpression:Expression:AcceptVisitor(SELF)
            SELF:EndNode(namedArgumentExpression)
            
        VIRTUAL METHOD VisitNamedExpression(namedExpression AS NamedExpression) AS VOID
            //
            SELF:StartNode(namedExpression)
            SELF:WriteIdentifier(namedExpression:NameToken)
            SELF:Space(TRUE)
            SELF:WriteToken(":=")
            SELF:Space(TRUE)
            namedExpression:Expression:AcceptVisitor(SELF)
            SELF:EndNode(namedExpression)
            
        PRIVATE METHOD VisitNamedNode(namedNode AS NamedNode) AS VOID
            //
            IF (! String.IsNullOrEmpty(namedNode:GroupName))
                //
                SELF:WriteIdentifier(namedNode:GroupName)
                SELF:WriteToken(":")
            ENDIF
            SELF:VisitNodeInPattern(namedNode:ChildNode)
            
        VIRTUAL METHOD VisitNamespaceDeclaration(namespaceDeclaration AS NamespaceDeclaration) AS VOID
            //
            SELF:StartNode(namespaceDeclaration)
            SELF:WriteKeyword("BEGIN")
            SELF:Space(TRUE)
            SELF:WriteKeyword("NAMESPACE")
            namespaceDeclaration:NamespaceName:AcceptVisitor(SELF)
            SELF:OpenBrace(SELF:policy:NamespaceBraceStyle)
            FOREACH node AS AstNode IN namespaceDeclaration:Members
                //
                node:AcceptVisitor(SELF)
                SELF:MaybeNewLinesAfterUsings(node)
            NEXT
            SELF:CloseBrace(SELF:policy:NamespaceBraceStyle)
            SELF:OptionalSemicolon(namespaceDeclaration:LastChild)
            SELF:NewLine()
            SELF:EndNode(namespaceDeclaration)
            
        VIRTUAL METHOD VisitNewLine(newLineNode AS NewLineNode) AS VOID
        
        
        PRIVATE METHOD VisitNodeInPattern(childNode AS INode) AS VOID
            //
            IF ((childNode IS AstNode))
                //
                ((AstNode)childNode ):AcceptVisitor(SELF)
            ELSE
                //
                IF ((childNode IS IdentifierExpressionBackreference))
                    //
                    SELF:VisitIdentifierExpressionBackreference((IdentifierExpressionBackreference)childNode )
                ELSE
                    //
                    IF ((childNode IS Choice))
                        //
                        SELF:VisitChoice((Choice)childNode )
                    ELSE
                        //
                        IF ((childNode IS AnyNode))
                            //
                            SELF:VisitAnyNode((AnyNode)childNode )
                        ELSE
                            //
                            IF ((childNode IS Backreference))
                                //
                                SELF:VisitBackreference((Backreference)childNode )
                            ELSE
                                //
                                IF ((childNode IS NamedNode))
                                    //
                                    SELF:VisitNamedNode((NamedNode)childNode )
                                ELSE
                                    //
                                    IF ((childNode IS OptionalNode))
                                        //
                                        SELF:VisitOptionalNode((OptionalNode)childNode )
                                    ELSE
                                        //
                                        IF ((childNode IS Repeat))
                                            //
                                            SELF:VisitRepeat((Repeat)childNode )
                                        ELSE
                                            //
                                            TextWriterTokenWriter.PrintPrimitiveValue(childNode)
                                        ENDIF
                                    ENDIF
                                ENDIF
                            ENDIF
                        ENDIF
                    ENDIF
                ENDIF
            ENDIF
            
        VIRTUAL METHOD VisitNullReferenceExpression(nullReferenceExpression AS NullReferenceExpression) AS VOID
            //
            SELF:StartNode(nullReferenceExpression)
            SELF:writer:WritePrimitiveValue(NULL, NULL)
            SELF:isAfterSpace := FALSE
            SELF:EndNode(nullReferenceExpression)
            
        VIRTUAL METHOD VisitObjectCreateExpression(objectCreateExpression AS ObjectCreateExpression) AS VOID
            LOCAL useBraces AS LOGIC
            //
            SELF:StartNode(objectCreateExpression)
            //SELF:WriteKeyword(ObjectCreateExpression.NewKeywordRole)
            objectCreateExpression:@@Type:AcceptVisitor(SELF)
            useBraces := (System.Linq.Enumerable.Any<Expression>(objectCreateExpression:Arguments) .OR. objectCreateExpression:Initializer:IsNull)
            IF (! objectCreateExpression:LParToken:IsNull)
                //
                useBraces := TRUE
            ENDIF
            IF (useBraces)
                //
                SELF:Space(SELF:policy:SpaceBeforeMethodCallParentheses)
                SELF:WriteCommaSeparatedListInBraces((System.Collections.Generic.IEnumerable<AstNode>)objectCreateExpression:Arguments , SELF:policy:SpaceWithinMethodCallParentheses)
            ELSE
                SELF:LBrace()
                SELF:Space(SELF:policy:SpaceWithinMethodCallParentheses)
                SELF:RBrace()
            ENDIF
            IF (!objectCreateExpression:Initializer:IsNull)
                SELF:WriteToken(";")
                objectCreateExpression:Initializer:AcceptVisitor(SELF)
            ENDIF
            SELF:EndNode(objectCreateExpression)
            
        VIRTUAL METHOD VisitOperatorDeclaration(operatorDeclaration AS OperatorDeclaration) AS VOID
            LOCAL needReturnType AS LOGIC
            //
            needReturnType := FALSE
            SELF:StartNode(operatorDeclaration)
            SELF:WriteAttributes(operatorDeclaration:Attributes)
            SELF:WriteModifiers(operatorDeclaration:ModifierTokens)
            IF (operatorDeclaration:OperatorType == OperatorType.Explicit)
                //
                SELF:WriteKeyword(OperatorDeclaration.ExplicitRole)
            ELSE
                //
                IF (operatorDeclaration:OperatorType == OperatorType.Implicit)
                    //
                    SELF:WriteKeyword(OperatorDeclaration.ImplicitRole)
                ELSE
                    //
                    needReturnType := TRUE
                    
                ENDIF
            ENDIF
            SELF:Space(TRUE)
            SELF:WriteKeyword(OperatorDeclaration.OperatorKeywordRole)
            SELF:Space(TRUE)
            IF ((operatorDeclaration:OperatorType == OperatorType.Explicit) .OR. (operatorDeclaration:OperatorType == OperatorType.Implicit))
                //
                operatorDeclaration:ReturnType:AcceptVisitor(SELF)
            ELSE
                //
                SELF:WriteToken(OperatorDeclaration.GetToken(operatorDeclaration:OperatorType), OperatorDeclaration.GetRole(operatorDeclaration:OperatorType))
            ENDIF
            SELF:Space(SELF:policy:SpaceBeforeMethodDeclarationParentheses)
            SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)operatorDeclaration:Parameters , SELF:policy:SpaceWithinMethodDeclarationParentheses)
            //
            IF ( needReturnType )
                SELF:Space(TRUE)
                SELF:WriteKeyword( "AS" )
                SELF:Space(TRUE)
                operatorDeclaration:ReturnType:AcceptVisitor(SELF)
            ENDIF
            //
            SELF:WriteMethodBody(operatorDeclaration:Body, SELF:policy:MethodBraceStyle)
            SELF:EndNode(operatorDeclaration)
            
        PRIVATE METHOD VisitOptionalNode(optionalNode AS OptionalNode) AS VOID
            //
            SELF:WriteKeyword("optional", NULL)
            SELF:LPar()
            SELF:VisitNodeInPattern(optionalNode:ChildNode)
            SELF:RPar()
            
        VIRTUAL METHOD VisitOutVarDeclarationExpression(outVarDeclarationExpression AS OutVarDeclarationExpression) AS VOID
            //
            SELF:StartNode(outVarDeclarationExpression)
            SELF:WriteKeyword("OUT")
            SELF:Space(TRUE)
            outVarDeclarationExpression:@@Type:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            outVarDeclarationExpression:Variable:AcceptVisitor(SELF)
            SELF:EndNode(outVarDeclarationExpression)
            
        VIRTUAL METHOD VisitParameterDeclaration(parameterDeclaration AS ParameterDeclaration) AS VOID
            //
            SELF:StartNode(parameterDeclaration)
            SELF:WriteAttributes(parameterDeclaration:Attributes)
            //
            IF ( parameterDeclaration:ParameterModifier == ParameterModifier.This)
                //
                SELF:WriteKeyword("SELF")
                SELF:Space(TRUE)
            ENDIF
            //
            IF (! String.IsNullOrEmpty(parameterDeclaration:Name))
                //
                SELF:WriteIdentifier(parameterDeclaration:NameToken)
            ENDIF
            IF (! parameterDeclaration:DefaultExpression:IsNull)
                //
                SELF:Space()
                SELF:WriteToken(":=")
                SELF:Space()
                parameterDeclaration:DefaultExpression:AcceptVisitor(SELF)
            ENDIF
            //
            SELF:Space()
            SWITCH parameterDeclaration:ParameterModifier
                CASE ParameterModifier.Ref
                    //
                    SELF:WriteKeyword("REF")
                    
                CASE ParameterModifier.Out
                    //
                    SELF:WriteKeyword("OUT")
                    
                CASE ParameterModifier.Params
                    //
                    SELF:WriteKeyword("PARAMS")
                OTHERWISE
                    //
                    SELF:WriteKeyword("AS")
            END SWITCH
            SELF:Space(TRUE)
            parameterDeclaration:@@Type:AcceptVisitor(SELF)
            //
            IF (! parameterDeclaration:@@Type:IsNull .AND. ! String.IsNullOrEmpty(parameterDeclaration:Name))
                //
                SELF:Space(TRUE)
            ENDIF
            
            
            SELF:EndNode(parameterDeclaration)
            
        VIRTUAL METHOD VisitParenthesizedExpression(parenthesizedExpression AS ParenthesizedExpression) AS VOID
            //
            SELF:StartNode(parenthesizedExpression)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinParentheses)
            parenthesizedExpression:Expression:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinParentheses)
            SELF:RPar()
            SELF:EndNode(parenthesizedExpression)
            
        VIRTUAL METHOD VisitPatternPlaceholder(placeholder AS AstNode, pattern AS Pattern) AS VOID
            //
            SELF:StartNode(placeholder)
            SELF:VisitNodeInPattern(pattern)
            SELF:EndNode(placeholder)
            
        VIRTUAL METHOD VisitPointerReferenceExpression(pointerReferenceExpression AS PointerReferenceExpression) AS VOID
            //
            SELF:StartNode(pointerReferenceExpression)
            pointerReferenceExpression:Target:AcceptVisitor(SELF)
            SELF:WriteToken(PointerReferenceExpression.ArrowRole)
            SELF:WriteIdentifier(pointerReferenceExpression:MemberNameToken)
            SELF:WriteTypeArguments(pointerReferenceExpression:TypeArguments)
            SELF:EndNode(pointerReferenceExpression)
            
        VIRTUAL METHOD VisitPreProcessorDirective(preProcessorDirective AS PreProcessorDirective) AS VOID
            //
            SELF:writer:StartNode(preProcessorDirective)
            SELF:writer:WritePreProcessorDirective(preProcessorDirective:@@Type, preProcessorDirective:Argument)
            SELF:writer:EndNode(preProcessorDirective)
            
        VIRTUAL METHOD VisitPrimitiveExpression(primitiveExpression AS PrimitiveExpression) AS VOID
            //
            SELF:StartNode(primitiveExpression)
            SELF:writer:WritePrimitiveValue(primitiveExpression:Value, primitiveExpression:UnsafeLiteralValue)
            // Store Parameters Name
            IF ( SELF:inMethodAttributes == ClipperState.Attribute) .AND. SELF:isClipper
                SELF:paramsList:Add( primitiveExpression:Value:ToString() )
            ENDIF
            //
            SELF:isAfterSpace := FALSE
            SELF:EndNode(primitiveExpression)
            
        VIRTUAL METHOD VisitPrimitiveType(primitiveType AS PrimitiveType) AS VOID
            //
            SELF:StartNode(primitiveType)
            SELF:writer:WritePrimitiveType(primitiveType:Keyword)
            IF SELF:isClipper .AND. ( SELF:inMethodAttributes==ClipperState.ReturnType )
                // If so, we have visiting the return Type
                SELF:paramsList:Insert( 0, primitiveType:Keyword)
            ENDIF
            SELF:isAfterSpace := FALSE
            SELF:EndNode(primitiveType)
            
        VIRTUAL METHOD VisitPropertyDeclaration(propertyDeclaration AS PropertyDeclaration) AS VOID
            LOCAL bodyStarted := FALSE AS LOGIC
            LOCAL bEmptyGet, bEmptySet AS LOGIC
            //
            SELF:StartNode(propertyDeclaration)
            SELF:WriteAttributes(propertyDeclaration:Attributes)
            SELF:WriteModifiers(propertyDeclaration:ModifierTokens)
            SELF:WriteKeyword("PROPERTY" )
            SELF:Space(TRUE)
            SELF:WritePrivateImplementationType(propertyDeclaration:PrivateImplementationType)
            SELF:WriteIdentifier(propertyDeclaration:NameToken)
            SELF:Space(TRUE)
            SELF:WriteKeyword("AS" )
            SELF:Space(TRUE)
            propertyDeclaration:ReturnType:AcceptVisitor(SELF)
            IF (propertyDeclaration:ExpressionBody:IsNull)
                // AUTO property ?
                bEmptySet := FALSE
                bEmptyGet := FALSE
                IF ( ( propertyDeclaration:Getter != NULL ) .AND. ( propertyDeclaration:Getter:Role == PropertyDeclaration.GetterRole ) )
                    IF ( propertyDeclaration:Getter:Body:IsNull )
                        bEmptyGet := TRUE
                    ENDIF
                ELSE
                    bEmptyGet := TRUE
                ENDIF
                IF ( ( propertyDeclaration:Setter != NULL ) .AND. ( propertyDeclaration:Setter:Role == PropertyDeclaration.SetterRole ) )
                    IF ( propertyDeclaration:Setter:Body:IsNull )
                        bEmptySet := TRUE
                    ENDIF
                ELSE
                    bEmptySet := TRUE
                ENDIF
                IF bEmptyGet .AND. bEmptySet
                    SELF:Space()
                    SELF:WriteKeyword("AUTO" )
                    SELF:Space()
                ENDIF
                //
                IF ( ( propertyDeclaration:Getter != NULL ) .AND. ( propertyDeclaration:Getter:Role == PropertyDeclaration.GetterRole ) )
                    IF ( propertyDeclaration:Getter:Body:IsNull )
                        SELF:Space()
                        SELF:WriteAttributes(propertyDeclaration:Getter:Attributes)
                        SELF:WriteModifiers(propertyDeclaration:Getter:ModifierTokens)
                        SELF:WriteKeyword("GET", PropertyDeclaration.GetKeywordRole)
                        SELF:Space()
                    ELSE
                        bodyStarted := TRUE
                        SELF:writer:Indent()
                        SELF:NewLine()
                        propertyDeclaration:Getter:AcceptVisitor( SELF )
                    ENDIF
                ENDIF
                IF ( ( propertyDeclaration:Setter != NULL ) .AND. ( propertyDeclaration:Setter:Role == PropertyDeclaration.SetterRole ) )
                    IF ( propertyDeclaration:Setter:Body:IsNull )
                        SELF:Space()
                        SELF:WriteAttributes(propertyDeclaration:Setter:Attributes)
                        SELF:WriteModifiers(propertyDeclaration:Setter:ModifierTokens)
                        SELF:WriteKeyword("SET", PropertyDeclaration.SetKeywordRole)
                        SELF:Space()
                    ELSE
                        IF !bodyStarted
                            bodyStarted := TRUE
                            SELF:writer:Indent()
                            SELF:NewLine()
                        ENDIF
                        propertyDeclaration:Setter:AcceptVisitor( SELF )
                    ENDIF
                ENDIF
                //
                IF (! propertyDeclaration:Initializer:IsNull)
                    //
                    SELF:Space(SELF:policy:SpaceAroundAssignment)
                    SELF:WriteToken(":=")
                    SELF:Space(SELF:policy:SpaceAroundAssignment)
                    propertyDeclaration:Initializer:AcceptVisitor(SELF)
                    SELF:Semicolon()
                ENDIF
                
                IF bodyStarted
                    SELF:writer:Unindent()
                    SELF:WriteKeyword("END" )
                    SELF:Space(TRUE)
                    SELF:WriteKeyword("PROPERTY" )
                ENDIF
                SELF:NewLine()
            ELSE
                //
                SELF:Space(TRUE)
                SELF:WriteKeyword("GET", PropertyDeclaration.GetKeywordRole)
                SELF:Space(TRUE)
                propertyDeclaration:ExpressionBody:AcceptVisitor(SELF)
                SELF:Semicolon()
            ENDIF
            SELF:EndNode(propertyDeclaration)
            
        VIRTUAL METHOD VisitQueryContinuationClause(queryContinuationClause AS QueryContinuationClause) AS VOID
            //
            SELF:StartNode(queryContinuationClause)
            queryContinuationClause:PrecedingQuery:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteKeyword(QueryContinuationClause.IntoKeywordRole)
            SELF:Space(TRUE)
            SELF:WriteIdentifier(queryContinuationClause:IdentifierToken)
            SELF:EndNode(queryContinuationClause)
            
        VIRTUAL METHOD VisitQueryExpression(queryExpression AS QueryExpression) AS VOID
            LOCAL flag AS LOGIC
            LOCAL flag2 AS LOGIC
            //
            SELF:StartNode(queryExpression)
            flag := ((queryExpression:Parent IS QueryClause) .AND. ! (queryExpression:Parent IS QueryContinuationClause))
            IF (flag)
                //
                SELF:writer:Indent()
                SELF:NewLine()
            ENDIF
            flag2 := TRUE
            FOREACH clause AS QueryClause IN queryExpression:Clauses
                //
                IF (flag2)
                    //
                    flag2 := FALSE
                ELSE
                    //
                    IF (! (clause IS QueryContinuationClause))
                        //
                        SELF:NewLine()
                    ENDIF
                ENDIF
                clause:AcceptVisitor(SELF)
            NEXT
            IF (flag)
                //
                SELF:writer:Unindent()
            ENDIF
            SELF:EndNode(queryExpression)
            
        VIRTUAL METHOD VisitQueryFromClause(queryFromClause AS QueryFromClause) AS VOID
            //
            SELF:StartNode(queryFromClause)
            SELF:WriteKeyword(QueryFromClause.FromKeywordRole)
            queryFromClause:@@Type:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteIdentifier(queryFromClause:IdentifierToken)
            SELF:Space(TRUE)
            SELF:WriteKeyword(QueryFromClause.InKeywordRole)
            SELF:Space(TRUE)
            queryFromClause:Expression:AcceptVisitor(SELF)
            SELF:EndNode(queryFromClause)
            
        VIRTUAL METHOD VisitQueryGroupClause(queryGroupClause AS QueryGroupClause) AS VOID
            //
            SELF:StartNode(queryGroupClause)
            SELF:WriteKeyword(QueryGroupClause.GroupKeywordRole)
            SELF:Space(TRUE)
            queryGroupClause:Projection:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteKeyword(QueryGroupClause.ByKeywordRole)
            SELF:Space(TRUE)
            queryGroupClause:Key:AcceptVisitor(SELF)
            SELF:EndNode(queryGroupClause)
            
        VIRTUAL METHOD VisitQueryJoinClause(queryJoinClause AS QueryJoinClause) AS VOID
            //
            SELF:StartNode(queryJoinClause)
            SELF:WriteKeyword(QueryJoinClause.JoinKeywordRole)
            queryJoinClause:@@Type:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteIdentifier(queryJoinClause:JoinIdentifierToken)
            SELF:Space(TRUE)
            SELF:WriteKeyword(QueryJoinClause.InKeywordRole)
            SELF:Space(TRUE)
            queryJoinClause:InExpression:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteKeyword(QueryJoinClause.OnKeywordRole)
            SELF:Space(TRUE)
            queryJoinClause:OnExpression:AcceptVisitor(SELF)
            SELF:Space(TRUE)
            SELF:WriteKeyword(QueryJoinClause.EqualsKeywordRole)
            SELF:Space(TRUE)
            queryJoinClause:EqualsExpression:AcceptVisitor(SELF)
            IF (queryJoinClause:IsGroupJoin)
                //
                SELF:Space(TRUE)
                SELF:WriteKeyword(QueryJoinClause.IntoKeywordRole)
                SELF:WriteIdentifier(queryJoinClause:IntoIdentifierToken)
            ENDIF
            SELF:EndNode(queryJoinClause)
            
        VIRTUAL METHOD VisitQueryLetClause(queryLetClause AS QueryLetClause) AS VOID
            //
            SELF:StartNode(queryLetClause)
            SELF:WriteKeyword(QueryLetClause.LetKeywordRole)
            SELF:Space(TRUE)
            SELF:WriteIdentifier(queryLetClause:IdentifierToken)
            SELF:Space(SELF:policy:SpaceAroundAssignment)
            SELF:WriteToken(":=")
            SELF:Space(SELF:policy:SpaceAroundAssignment)
            queryLetClause:Expression:AcceptVisitor(SELF)
            SELF:EndNode(queryLetClause)
            
        VIRTUAL METHOD VisitQueryOrderClause(queryOrderClause AS QueryOrderClause) AS VOID
            //
            SELF:StartNode(queryOrderClause)
            SELF:WriteKeyword(QueryOrderClause.OrderbyKeywordRole)
            SELF:Space(TRUE)
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)queryOrderClause:Orderings )
            SELF:EndNode(queryOrderClause)
            
        VIRTUAL METHOD VisitQueryOrdering(queryOrdering AS QueryOrdering) AS VOID
            //
            SELF:StartNode(queryOrdering)
            queryOrdering:Expression:AcceptVisitor(SELF)
            SWITCH queryOrdering:Direction
                CASE QueryOrderingDirection.Ascending
                    //
                    SELF:Space(TRUE)
                    SELF:WriteKeyword(QueryOrdering.AscendingKeywordRole)
                    
                CASE QueryOrderingDirection.Descending
                    //
                    SELF:Space(TRUE)
                    SELF:WriteKeyword(QueryOrdering.DescendingKeywordRole)
                    
            END SWITCH
            SELF:EndNode(queryOrdering)
            
        VIRTUAL METHOD VisitQuerySelectClause(querySelectClause AS QuerySelectClause) AS VOID
            //
            SELF:StartNode(querySelectClause)
            SELF:WriteKeyword(QuerySelectClause.SelectKeywordRole)
            SELF:Space(TRUE)
            querySelectClause:Expression:AcceptVisitor(SELF)
            SELF:EndNode(querySelectClause)
            
        VIRTUAL METHOD VisitQueryWhereClause(queryWhereClause AS QueryWhereClause) AS VOID
            //
            SELF:StartNode(queryWhereClause)
            SELF:WriteKeyword(QueryWhereClause.WhereKeywordRole)
            SELF:Space(TRUE)
            queryWhereClause:Condition:AcceptVisitor(SELF)
            SELF:EndNode(queryWhereClause)
            
        PRIVATE METHOD VisitRepeat(@@repeat AS Repeat) AS VOID
            //
            SELF:WriteKeyword("repeat", NULL)
            SELF:LPar()
            IF ((@@repeat:MinCount != 0) .OR. (@@repeat:MaxCount != 0x7fffffff))
                //
                SELF:WriteIdentifier(@@repeat:MinCount:ToString())
                SELF:WriteToken(XSRoles.Comma)
                SELF:WriteIdentifier(@@repeat:MaxCount:ToString())
                SELF:WriteToken(XSRoles.Comma)
            ENDIF
            SELF:VisitNodeInPattern(@@repeat:ChildNode)
            SELF:RPar()
            
        VIRTUAL METHOD VisitReturnStatement(returnStatement AS ReturnStatement) AS VOID
            //
            SELF:StartNode(returnStatement)
            SELF:WriteKeyword(ReturnStatement.ReturnKeywordRole)
            IF (! returnStatement:Expression:IsNull)
                //
                SELF:Space(TRUE)
                returnStatement:Expression:AcceptVisitor(SELF)
            ENDIF
            SELF:NewLine()
            SELF:EndNode(returnStatement)
            
        VIRTUAL METHOD VisitSimpleType(simpleType AS SimpleType) AS VOID
            //
            SELF:StartNode(simpleType)
            SELF:WriteIdentifier(simpleType:IdentifierToken)
            // Flag ClipperCallingConvention attribute
            IF ( SELF:inMethodAttributes == ClipperState.Attribute )
                IF ( String.Compare( simpleType:Identifier, "clippercallingconvention", TRUE ) == 0 )
                    SELF:isClipper := TRUE
                ENDIF
            ELSE
                IF SELF:isClipper .AND. ( SELF:inMethodAttributes == ClipperState.ReturnType )
                    // If so, we have visiting the return Type
                    SELF:paramsList:Insert( 0, simpleType:Identifier)
                ENDIF
            ENDIF
            SELF:WriteTypeArguments(simpleType:TypeArguments)
            SELF:EndNode(simpleType)
            
        VIRTUAL METHOD VisitSizeOfExpression(sizeOfExpression AS SizeOfExpression) AS VOID
            //
            SELF:StartNode(sizeOfExpression)
            SELF:WriteKeyword(SizeOfExpression.SizeofKeywordRole)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinSizeOfParentheses)
            sizeOfExpression:@@Type:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinSizeOfParentheses)
            SELF:RPar()
            SELF:EndNode(sizeOfExpression)
            
        VIRTUAL METHOD VisitStackAllocExpression(stackAllocExpression AS StackAllocExpression) AS VOID
            LOCAL list AS Expression[]
            //
            SELF:StartNode(stackAllocExpression)
            SELF:WriteKeyword(StackAllocExpression.StackallocKeywordRole)
            stackAllocExpression:@@Type:AcceptVisitor(SELF)
            list := <Expression>{stackAllocExpression:CountExpression}
            SELF:WriteCommaSeparatedListInBrackets(list)
            SELF:EndNode(stackAllocExpression)
            
        VIRTUAL METHOD VisitSwitchSection(switchSection AS SwitchSection) AS VOID
            LOCAL flag AS LOGIC
            LOCAL flag2 AS LOGIC
            //
            SELF:StartNode(switchSection)
            flag := TRUE
            FOREACH label AS CaseLabel IN switchSection:CaseLabels
                //
                IF (! flag)
                    //
                    SELF:NewLine()
                ENDIF
                label:AcceptVisitor(SELF)
                flag := FALSE
            NEXT
            flag2 := ((switchSection:Statements:Count == 1) .AND. (System.Linq.Enumerable.Single<Statement>(switchSection:Statements) IS BlockStatement))
            IF (SELF:policy:IndentCaseBody .AND. ! flag2)
                //
                SELF:writer:Indent()
            ENDIF
            IF (! flag2)
                //
                SELF:NewLine()
            ENDIF
            FOREACH statement AS Statement IN switchSection:Statements
                //
                IF !( statement IS BreakStatement )
                    statement:AcceptVisitor(SELF)
                ENDIF
            NEXT
            IF (SELF:policy:IndentCaseBody .AND. ! flag2)
                //
                SELF:writer:Unindent()
            ENDIF
            SELF:EndNode(switchSection)
            
        VIRTUAL METHOD VisitSwitchStatement(switchStatement AS SwitchStatement) AS VOID
            //
            SELF:StartNode(switchStatement)
            SELF:WriteKeyword("BEGIN")
            SELF:Space(TRUE)
            SELF:WriteKeyword("SWITCH")
            SELF:Space(TRUE)
            switchStatement:Expression:AcceptVisitor(SELF)
            SELF:OpenBrace(SELF:policy:StatementBraceStyle)
            IF (! SELF:policy:IndentSwitchBody)
                //
                SELF:writer:Unindent()
            ENDIF
            FOREACH section AS SwitchSection IN switchStatement:SwitchSections
                //
                section:AcceptVisitor(SELF)
            NEXT
            IF (! SELF:policy:IndentSwitchBody)
                //
                SELF:writer:Indent()
            ENDIF
            SELF:CloseBrace(SELF:policy:StatementBraceStyle)
            SELF:WriteKeyword("END")
            SELF:Space(TRUE)
            SELF:WriteKeyword("SWITCH")
            SELF:NewLine()
            SELF:EndNode(switchStatement)
            
        VIRTUAL METHOD VisitSyntaxTree(syntaxTree AS SyntaxTree) AS VOID
            //
            FOREACH node AS AstNode IN syntaxTree:Children
                //
                node:AcceptVisitor(SELF)
                SELF:MaybeNewLinesAfterUsings(node)
            NEXT
            
        VIRTUAL METHOD VisitText(textNode AS TextNode) AS VOID
        
        
        VIRTUAL METHOD VisitThisReferenceExpression(thisReferenceExpression AS ThisReferenceExpression) AS VOID
            //
            SELF:StartNode(thisReferenceExpression)
            SELF:WriteKeyword("SELF", thisReferenceExpression:Role)
            SELF:EndNode(thisReferenceExpression)
            
        VIRTUAL METHOD VisitThrowExpression(throwExpression AS ThrowExpression) AS VOID
            //
            SELF:StartNode(throwExpression)
            SELF:WriteKeyword("THROW")
            SELF:Space(TRUE)
            throwExpression:Expression:AcceptVisitor(SELF)
            SELF:EndNode(throwExpression)
            
        VIRTUAL METHOD VisitThrowStatement(throwStatement AS ThrowStatement) AS VOID
            //
            SELF:StartNode(throwStatement)
            SELF:WriteKeyword("THROW")
            IF (! throwStatement:Expression:IsNull)
                //
                SELF:Space(TRUE)
                throwStatement:Expression:AcceptVisitor(SELF)
            ENDIF
            SELF:NewLine()
            SELF:EndNode(throwStatement)
            
        VIRTUAL METHOD VisitTryCatchStatement(tryCatchStatement AS TryCatchStatement) AS VOID
            //
            SELF:StartNode(tryCatchStatement)
            SELF:WriteKeyword("TRY")
            SELF:WriteBlock(tryCatchStatement:TryBlock, SELF:policy:StatementBraceStyle)
            FOREACH clause AS CatchClause IN tryCatchStatement:CatchClauses
                //
                IF (SELF:policy:CatchNewLinePlacement == NewLinePlacement.SameLine)
                    //
                    SELF:Space(TRUE)
                ELSE
                    //
                    SELF:NewLine()
                ENDIF
                clause:AcceptVisitor(SELF)
            NEXT
            IF (! tryCatchStatement:FinallyBlock:IsNull)
                //
                IF (SELF:policy:FinallyNewLinePlacement == NewLinePlacement.SameLine)
                    //
                    SELF:Space(TRUE)
                ELSE
                    //
                    SELF:NewLine()
                ENDIF
                SELF:WriteKeyword("FINALLY")
                SELF:WriteBlock(tryCatchStatement:FinallyBlock, SELF:policy:StatementBraceStyle)
            ENDIF
            SELF:WriteKeyword("END")
            SELF:Space(TRUE)
            SELF:WriteKeyword("TRY")
            SELF:NewLine()
            SELF:EndNode(tryCatchStatement)
            
        VIRTUAL METHOD VisitTupleExpression(tupleExpression AS TupleExpression ) AS VOID
            SELF:StartNode(tupleExpression)
            SELF:LPar()
            SELF:WriteCommaSeparatedList(tupleExpression:Elements)
            SELF:RPar()
            SELF:EndNode(tupleExpression)
            
        VIRTUAL METHOD VisitTupleType(tupleType AS TupleAstType ) AS VOID
            SELF:StartNode(tupleType)
            SELF:LPar()
            SELF:WriteCommaSeparatedList(tupleType:Elements)
            SELF:RPar()
            SELF:EndNode(tupleType)
            
            
        VIRTUAL METHOD VisitTupleTypeElement(tupleTypeElement AS TupleTypeElement ) AS VOID
            SELF:StartNode(tupleTypeElement)
            tupleTypeElement:Type:AcceptVisitor(SELF)
            IF (!tupleTypeElement:NameToken:IsNull)
                SELF:Space(TRUE)
                tupleTypeElement:NameToken:AcceptVisitor(SELF)
            ENDIF
            SELF:EndNode(tupleTypeElement)
            
            
        VIRTUAL METHOD VisitTypeDeclaration(typeDeclaration AS TypeDeclaration) AS VOID
            LOCAL structBraceStyle AS BraceStyle
            LOCAL flag AS LOGIC
            LOCAL node AS AstNode
            LOCAL flag2 AS LOGIC
            LOCAL i AS LONG
            //
            SELF:StartNode(typeDeclaration)
            SELF:WriteAttributes(typeDeclaration:Attributes)
            SELF:WriteModifiers(typeDeclaration:ModifierTokens)
            SWITCH typeDeclaration:ClassType
                CASE ClassType.Struct
                    //
                    SELF:WriteKeyword("STRUCTURE")
                    structBraceStyle := SELF:policy:StructBraceStyle
                CASE ClassType.Interface
                    //
                    SELF:WriteKeyword("INTERFACE")
                    structBraceStyle := SELF:policy:InterfaceBraceStyle
                CASE ClassType.Enum
                    //
                    SELF:WriteKeyword("ENUM")
                    structBraceStyle := SELF:policy:EnumBraceStyle
                OTHERWISE
                    //
                    SELF:WriteKeyword("CLASS")
                    structBraceStyle := SELF:policy:ClassBraceStyle
            END SWITCH
            SELF:Space(TRUE)
            SELF:WriteIdentifier(typeDeclaration:NameToken)
            SELF:WriteTypeParameters(typeDeclaration:TypeParameters)
            IF (typeDeclaration:BaseTypes:Any())
                //
                IF ( typeDeclaration:ClassType == ClassType.Enum )
                    SELF:Space()
                    SELF:WriteKeyword("AS")
                    SELF:Space()
                    SELF:WriteCommaSeparatedList(typeDeclaration:BaseTypes)
                ELSE
                    LOCAL typeList AS System.Collections.Generic.IEnumerable<AstType>
                    LOCAL classList AS List<AstType>
                    classList := List<AstType>{}
                    LOCAL interfaceList AS List<AstType>
                    interfaceList := List<AstType>{}
                    //
                    typeList := typeDeclaration:BaseTypes
                    FOREACH typeDef AS AstType IN typeList
                        LOCAL sym AS ISymbol
                        sym := typeDef:GetSymbol()
                        LOCAL t AS ITypeDefinition
                        t := sym ASTYPE ITypeDefinition
                        IF ( t!= NULL )
                            IF ( t:Kind == TypeKind.Interface )
                                interfaceList:Add( typeDef )
                            ELSEIF ( t:Kind == TypeKind.Class )
                                classList:Add( typeDef )
                            ENDIF
                        ENDIF
                    NEXT
                    IF ( classList:Count > 0 )
                        SELF:Space(TRUE)
                        SELF:WriteKeyword( "INHERIT" )
                        SELF:Space(TRUE)
                        SELF:WriteCommaSeparatedList(classList )
                    ENDIF
                    IF ( interfaceList:Count > 0 )
                        SELF:Space(TRUE)
                        SELF:WriteKeyword( "IMPLEMENTS" ) 
                        SELF:Space(TRUE)
                        SELF:WriteCommaSeparatedList(interfaceList)
                    ENDIF
                ENDIF
            ENDIF
            FOREACH constraint AS Constraint IN typeDeclaration:Constraints
                //
                constraint:AcceptVisitor(SELF)
            NEXT
            SELF:OpenBrace(structBraceStyle)
            IF (typeDeclaration:ClassType == ClassType.Enum)
                //
                flag := TRUE
                node := NULL
                FOREACH declaration AS EntityDeclaration IN typeDeclaration:Members
                    //
                    IF (flag)
                        //
                        flag := FALSE
                    ELSE
                        //
                        //SELF:Comma(declaration, TRUE)
                        SELF:NewLine()
                    ENDIF
                    node := declaration
                    declaration:AcceptVisitor(SELF)
                NEXT
                IF (node != NULL)
                    //
                    SELF:OptionalComma(node:NextSibling)
                ENDIF
                SELF:NewLine()
            ELSE
                //
                flag2 := TRUE
                FOREACH declaration2 AS EntityDeclaration IN typeDeclaration:Members
                    //
                    IF (! flag2)
                        //
                        i := 0
                        WHILE ((i < SELF:policy:MinimumBlankLinesBetweenMembers))
                            //
                            SELF:NewLine()
                            i++
                        ENDDO
                    ENDIF
                    flag2 := FALSE
                    declaration2:AcceptVisitor(SELF)
                NEXT
            ENDIF
            SELF:CloseBrace(structBraceStyle)
            SELF:OptionalSemicolon(typeDeclaration:LastChild)
            SELF:NewLine()
            SELF:WriteKeyword("END")
            SELF:Space(TRUE)
            SWITCH typeDeclaration:ClassType
                CASE ClassType.Struct
                    //
                    SELF:WriteKeyword("STRUCTURE")
                CASE ClassType.Interface
                    //
                    SELF:WriteKeyword("INTERFACE")
                CASE ClassType.Enum
                    //
                    SELF:WriteKeyword("ENUM")
                OTHERWISE
                    //
                    SELF:WriteKeyword("CLASS")
            END SWITCH
            SELF:NewLine()
            SELF:EndNode(typeDeclaration)
            
        VIRTUAL METHOD VisitTypeOfExpression(typeOfExpression AS TypeOfExpression) AS VOID
            //
            SELF:StartNode(typeOfExpression)
            SELF:WriteKeyword(TypeOfExpression.TypeofKeywordRole)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinTypeOfParentheses)
            typeOfExpression:@@Type:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinTypeOfParentheses)
            SELF:RPar()
            SELF:EndNode(typeOfExpression)
            
        VIRTUAL METHOD VisitTypeParameterDeclaration(typeParameterDeclaration AS TypeParameterDeclaration) AS VOID
            //
            SELF:StartNode(typeParameterDeclaration)
            SELF:WriteAttributes(typeParameterDeclaration:Attributes)
            SWITCH typeParameterDeclaration:Variance
                CASE VarianceModifier.Invariant
                    //
                    NOP
                CASE VarianceModifier.Covariant
                    //
                    SELF:WriteKeyword(TypeParameterDeclaration.OutVarianceKeywordRole)
                    
                CASE VarianceModifier.Contravariant
                    //
                    SELF:WriteKeyword(TypeParameterDeclaration.InVarianceKeywordRole)
                    
                OTHERWISE
                    //
                    THROW System.NotSupportedException{"Invalid value for VarianceModifier"}
            END SWITCH
            SELF:WriteIdentifier(typeParameterDeclaration:NameToken)
            SELF:EndNode(typeParameterDeclaration)
            
        VIRTUAL METHOD VisitTypeReferenceExpression(typeReferenceExpression AS TypeReferenceExpression) AS VOID
            //
            SELF:StartNode(typeReferenceExpression)
            typeReferenceExpression:@@Type:AcceptVisitor(SELF)
            SELF:EndNode(typeReferenceExpression)
            
        VIRTUAL METHOD VisitUnaryOperatorExpression(unaryOperatorExpression AS UnaryOperatorExpression) AS VOID
            LOCAL uOperator AS UnaryOperatorType
            LOCAL operatorRole AS TokenRole
            //
            SELF:StartNode(unaryOperatorExpression)
            uOperator := unaryOperatorExpression:Operator
            operatorRole := UnaryOperatorExpression.GetOperatorRole(uOperator)
            IF (uOperator == UnaryOperatorType.Await)
                //
                SELF:WriteKeyword(operatorRole)
            ELSE
                //
                IF (! XSharpOutputVisitor.IsPostfixOperator(uOperator) .AND. (uOperator != UnaryOperatorType.NullConditionalRewrap))
                    //
                    SELF:WriteToken(operatorRole)
                ENDIF
            ENDIF
            unaryOperatorExpression:Expression:AcceptVisitor(SELF)
            IF (XSharpOutputVisitor.IsPostfixOperator(uOperator))
                //
                SELF:WriteToken(operatorRole)
            ENDIF
            SELF:EndNode(unaryOperatorExpression)
            
        VIRTUAL METHOD VisitUncheckedExpression(uncheckedExpression AS UncheckedExpression) AS VOID
            //
            SELF:StartNode(uncheckedExpression)
            SELF:WriteKeyword(UncheckedExpression.UncheckedKeywordRole)
            SELF:LPar()
            SELF:Space(SELF:policy:SpacesWithinCheckedExpressionParantheses)
            uncheckedExpression:Expression:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinCheckedExpressionParantheses)
            SELF:RPar()
            SELF:EndNode(uncheckedExpression)
            
        VIRTUAL METHOD VisitUncheckedStatement(uncheckedStatement AS UncheckedStatement) AS VOID
            //
            SELF:StartNode(uncheckedStatement)
            SELF:WriteKeyword(UncheckedStatement.UncheckedKeywordRole)
            uncheckedStatement:Body:AcceptVisitor(SELF)
            SELF:EndNode(uncheckedStatement)
            
        VIRTUAL METHOD VisitUndocumentedExpression(undocumentedExpression AS UndocumentedExpression) AS VOID
            //
            SELF:StartNode(undocumentedExpression)
            SWITCH undocumentedExpression:UndocumentedExpressionType
            CASE UndocumentedExpressionType.ArgListAccess
                CASE UndocumentedExpressionType.ArgList
                    //
                    SELF:WriteKeyword(UndocumentedExpression.ArglistKeywordRole)
                    
                CASE UndocumentedExpressionType.RefValue
                    //
                    SELF:WriteKeyword(UndocumentedExpression.RefvalueKeywordRole)
                    
                CASE UndocumentedExpressionType.RefType
                    //
                    SELF:WriteKeyword(UndocumentedExpression.ReftypeKeywordRole)
                    
                CASE UndocumentedExpressionType.MakeRef
                    //
                    SELF:WriteKeyword(UndocumentedExpression.MakerefKeywordRole)
                    
                END SWITCH
            IF (undocumentedExpression:UndocumentedExpressionType != UndocumentedExpressionType.ArgListAccess)
                //
                SELF:Space(SELF:policy:SpaceBeforeMethodCallParentheses)
                SELF:WriteCommaSeparatedListInParenthesis((System.Collections.Generic.IEnumerable<AstNode>)undocumentedExpression:Arguments , SELF:policy:SpaceWithinMethodCallParentheses)
            ENDIF
            SELF:EndNode(undocumentedExpression)
            
        VIRTUAL METHOD VisitUnsafeStatement(unsafeStatement AS UnsafeStatement) AS VOID
            //
            SELF:StartNode(unsafeStatement)
            SELF:WriteKeyword(UnsafeStatement.UnsafeKeywordRole)
            unsafeStatement:Body:AcceptVisitor(SELF)
            SELF:EndNode(unsafeStatement)
            
        VIRTUAL METHOD VisitUsingAliasDeclaration(usingAliasDeclaration AS UsingAliasDeclaration) AS VOID
            //
            SELF:StartNode(usingAliasDeclaration)
            SELF:WriteKeyword(UsingAliasDeclaration.UsingKeywordRole)
            SELF:WriteIdentifier(usingAliasDeclaration:GetChildByRole<Identifier>(UsingAliasDeclaration.AliasRole))
            SELF:Space(SELF:policy:SpaceAroundEqualityOperator)
            SELF:WriteToken(":=")
            SELF:Space(SELF:policy:SpaceAroundEqualityOperator)
            usingAliasDeclaration:Import:AcceptVisitor(SELF)
            SELF:Semicolon()
            SELF:EndNode(usingAliasDeclaration)
            
        VIRTUAL METHOD VisitUsingDeclaration(usingDeclaration AS UsingDeclaration) AS VOID
            //
            SELF:StartNode(usingDeclaration)
            SELF:WriteKeyword("USING")
            SELF:Space( TRUE )
            usingDeclaration:Import:AcceptVisitor(SELF)
            SELF:NewLine()
            SELF:EndNode(usingDeclaration)
            
        VIRTUAL METHOD VisitUsingStatement(usingStatement AS UsingStatement) AS VOID
            //
            SELF:StartNode(usingStatement)
            SELF:WriteKeyword("BEGIN")
            SELF:Space(TRUE)
            SELF:WriteKeyword("USING")
            SELF:Space(TRUE)
            usingStatement:ResourceAcquisition:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinUsingParentheses)
            SELF:WriteEmbeddedStatement(usingStatement:EmbeddedStatement, NewLinePlacement.NewLine)
            SELF:WriteKeyword("END")
            SELF:Space(TRUE)
            SELF:WriteKeyword("USING")
            SELF:NewLine()
            SELF:EndNode(usingStatement)
            
        VIRTUAL METHOD VisitVariableDeclarationStatement(variableDeclarationStatement AS VariableDeclarationStatement) AS VOID
            // Now that LOCALs are declare on top of Statement
            SELF:WriteCommaSeparatedList((System.Collections.Generic.IEnumerable<AstNode>)variableDeclarationStatement:Variables )
            
        VIRTUAL METHOD VisitVariableInitializer(variableInitializer AS VariableInitializer) AS VOID
            //
            SELF:StartNode(variableInitializer)
            //   
            SELF:Prefix( variableInitializer )
            SELF:Prefix( variableInitializer )
            //
            SELF:WriteIdentifier(variableInitializer:NameToken)
            //
            IF (! variableInitializer:Initializer:IsNull)
                SELF:Space(SELF:policy:SpaceAroundAssignment)
                SELF:WriteToken(":=")
                SELF:Space(SELF:policy:SpaceAroundAssignment)
                variableInitializer:Initializer:AcceptVisitor(SELF)
            ENDIF
            SELF:EndNode(variableInitializer)
            
        VIRTUAL METHOD VisitWhileStatement(whileStatement AS WhileStatement) AS VOID
            //
            SELF:StartNode(whileStatement)
            SELF:WriteKeyword("WHILE")
            SELF:Space(TRUE)
            whileStatement:Condition:AcceptVisitor(SELF)
            SELF:Space(SELF:policy:SpacesWithinWhileParentheses)
            SELF:WriteEmbeddedStatement(whileStatement:EmbeddedStatement, NewLinePlacement.NewLine)
            SELF:WriteKeyword("END")
            SELF:Space(TRUE)
            SELF:WriteKeyword("WHILE")
            SELF:NewLine()
            SELF:EndNode(whileStatement)
            
        VIRTUAL METHOD VisitWhitespace(whitespaceNode AS WhitespaceNode) AS VOID
        
        
        VIRTUAL METHOD VisitYieldBreakStatement(yieldBreakStatement AS YieldBreakStatement) AS VOID
            //
            SELF:StartNode(yieldBreakStatement)
            SELF:WriteKeyword(YieldBreakStatement.YieldKeywordRole)
            SELF:WriteKeyword(YieldBreakStatement.BreakKeywordRole)
            SELF:Semicolon()
            SELF:EndNode(yieldBreakStatement)
            
        VIRTUAL METHOD VisitYieldReturnStatement(yieldReturnStatement AS YieldReturnStatement) AS VOID
            //
            SELF:StartNode(yieldReturnStatement)
            SELF:WriteKeyword(YieldReturnStatement.YieldKeywordRole)
            SELF:WriteKeyword(YieldReturnStatement.ReturnKeywordRole)
            SELF:Space(TRUE)
            yieldReturnStatement:Expression:AcceptVisitor(SELF)
            SELF:Semicolon()
            SELF:EndNode(yieldReturnStatement)
            
        PROTECTED VIRTUAL METHOD WriteAttributes(attributes AS System.Collections.Generic.IEnumerable<AttributeSection>) AS VOID
            //
            FOREACH section AS AttributeSection IN attributes
                //
                section:AcceptVisitor(SELF)
            NEXT
            
        PROTECTED VIRTUAL METHOD WriteBlock(blockStatement AS BlockStatement, style AS BraceStyle) AS VOID
            //
            SELF:StartNode(blockStatement)
            SELF:OpenBrace(style)
            FOREACH statement AS Statement IN blockStatement:Statements
                //
                statement:AcceptVisitor(SELF)
                IF ( statement IS VariableDeclarationStatement )
                    SELF:NewLine()
                ENDIF
            NEXT
            //
            SELF:CloseBrace(style)
            SELF:EndNode(blockStatement)
            
        PROTECTED VIRTUAL METHOD WriteSingleCommment( comment AS STRING ) AS VOID
            //
            SELF:writer:WriteComment( CommentType.SingleLine, comment)
            SELF:isAtStartOfLine := TRUE
            
        PROTECTED VIRTUAL METHOD WriteCommaSeparatedList(list AS System.Collections.Generic.IEnumerable<AstNode>) AS VOID
            LOCAL flag AS LOGIC
            //
            flag := TRUE
            FOREACH node AS AstNode IN list
                //
                IF (flag)
                    //
                    flag := FALSE
                ELSE
                    //
                    SELF:Comma(node, FALSE)
                ENDIF
                node:AcceptVisitor(SELF)
            NEXT
            
        PROTECTED VIRTUAL METHOD WriteCommaSeparatedListInBrackets(list AS System.Collections.Generic.IEnumerable<Expression>) AS VOID
            //
            SELF:WriteToken(XSRoles.LBracket)
            IF (System.Linq.Enumerable.Any<Expression>(list))
                //
                SELF:Space(SELF:policy:SpacesWithinBrackets)
                SELF:WriteCommaSeparatedList(list)
                SELF:Space(SELF:policy:SpacesWithinBrackets)
            ENDIF
            SELF:WriteToken(XSRoles.RBracket)
            
        PROTECTED VIRTUAL METHOD WriteCommaSeparatedListInBrackets(list AS System.Collections.Generic.IEnumerable<ParameterDeclaration>, spaceWithin AS LOGIC) AS VOID
            //
            SELF:WriteToken(XSRoles.LBracket)
            IF (System.Linq.Enumerable.Any<ParameterDeclaration>(list))
                //
                SELF:Space(spaceWithin)
                SELF:WriteCommaSeparatedList(list)
                SELF:Space(spaceWithin)
            ENDIF
            SELF:WriteToken(XSRoles.RBracket)
            
        PROTECTED VIRTUAL METHOD WriteCommaSeparatedListInParenthesis(list AS System.Collections.Generic.IEnumerable<AstNode>, spaceWithin AS LOGIC) AS VOID
            //
            SELF:LPar()
            IF (System.Linq.Enumerable.Any<AstNode>(list))
                //
                SELF:Space(spaceWithin)
                SELF:WriteCommaSeparatedList(list)
                SELF:Space(spaceWithin)
            ENDIF
            SELF:RPar()
            
        PROTECTED VIRTUAL METHOD WriteCommaSeparatedListInBraces(list AS System.Collections.Generic.IEnumerable<AstNode>, spaceWithin AS LOGIC) AS VOID
            //
            SELF:LBrace()
            IF (System.Linq.Enumerable.Any<AstNode>(list))
                //
                SELF:Space(spaceWithin)
                SELF:WriteCommaSeparatedList(list)
                SELF:Space(spaceWithin)
            ENDIF
            SELF:RBrace()
            
            
        PROTECTED VIRTUAL METHOD WriteEmbeddedStatement(embeddedStatement AS Statement,  nlp AS NewLinePlacement) AS VOID
            LOCAL blockStatement AS BlockStatement
            //
            IF (embeddedStatement:IsNull)
                //
                SELF:NewLine()
            ELSE
                //
                blockStatement := embeddedStatement ASTYPE BlockStatement
                IF (blockStatement != NULL)
                    //
                    SELF:WriteBlock(blockStatement, SELF:policy:StatementBraceStyle)
                ELSE
                    //
                    SELF:NewLine()
                    SELF:writer:Indent()
                    embeddedStatement:AcceptVisitor(SELF)
                    SELF:writer:Unindent()
                ENDIF
            ENDIF
            
        PROTECTED VIRTUAL METHOD WriteIdentifier(identifier AS Identifier) AS VOID
            //
            VAR mbr := GetMemberReference( identifier )
            IF (mbr != NULL) 
                LOCAL cecil AS MemberReference
                cecil := SymbolToCecil(mbr)
                
            ENDIF
            //
            SELF:writer:WriteIdentifier(identifier)
            SELF:isAtStartOfLine := FALSE
            SELF:isAfterSpace := FALSE
            
        PROTECTED VIRTUAL METHOD WriteIdentifier(identifier AS STRING) AS VOID
            //
            AstType.Create(identifier):AcceptVisitor(SELF)
            SELF:isAtStartOfLine := FALSE
            SELF:isAfterSpace := FALSE
            
        PROTECTED VIRTUAL METHOD WriteKeyword(tokenRole AS TokenRole) AS VOID
            //
            SELF:WriteKeyword(tokenRole:Token, tokenRole)
            
        PROTECTED VIRTUAL METHOD WriteKeyword(token AS STRING,  tokenRole := NULL AS Role) AS VOID
            //
            SELF:writer:WriteKeyword(tokenRole, token)
            SELF:isAtStartOfLine := FALSE
            SELF:isAfterSpace := FALSE
            
        PROTECTED VIRTUAL METHOD WriteMethodBody(body AS BlockStatement, style AS BraceStyle) AS VOID
            LOCAL cmt := "" AS STRING
            //
            IF ( SELF:isClipper ) 
                // Build Clipper Calling Convention comment
                IF ( SELF:paramsList:Count >= 2 )
                    //
                    cmt := "FUNCTION " + SELF:paramsList[0] + "("
                    FOR VAR i:=2 TO SELF:paramsList:Count-1
                        IF ( i>2 )
                            cmt += ","
                        ENDIF
                        cmt += SELF:paramsList[i]
                    NEXT
                    cmt += ") AS " + SELF:paramsList[1]
                    //
                ENDIF
            ENDIF
            //
            IF (body:IsNull)
                //
                SELF:Semicolon()
            ELSE
                // Indent code inside Body
                SELF:NewLine()
                SELF:writer:Indent()
                IF ( !STRING.IsNullOrEmpty( cmt ) )
                    SELF:WriteSingleCommment( cmt )
                ENDIF
                // First Try to declare all LOCALs
                LOCAL localVisitor := XSharpLocalVisitor{ SELF:writer, SELF:policy, SELF } AS XSharpLocalVisitor
                FOREACH statement AS Statement IN body:Statements
                    //
                    statement:AcceptVisitor( localVisitor )
                NEXT
                //
                IF ( localVisitor:Variables:Count > 0 )
                    SELF:WriteSingleCommment( "" )
                ENDIF
                SELF:writer:Unindent()
                // Now, Generate Code
                SELF:WriteBlock(body, style)
                SELF:NewLine()
            ENDIF
            
        PROTECTED VIRTUAL METHOD WriteModifiers(modifierTokens AS System.Collections.Generic.IEnumerable<CSharpModifierToken>) AS VOID
            //
            FOREACH token AS CSharpModifierToken IN modifierTokens
                //
                SELF:WriteKeyword( XSharpTokenHelper.GetModifierName( token:Modifier ) )
                SELF:Space(TRUE)
            NEXT
            
        PROTECTED VIRTUAL METHOD WritePrivateImplementationType(privateImplementationType AS AstType) AS VOID
            //
            IF (! privateImplementationType:IsNull)
                //
                privateImplementationType:AcceptVisitor(SELF)
                SELF:WriteToken(".")
            ENDIF
            
        PROTECTED VIRTUAL METHOD WriteQualifiedIdentifier(identifiers AS System.Collections.Generic.IEnumerable<Identifier>) AS VOID
            LOCAL flag AS LOGIC
            //
            flag := TRUE
            FOREACH identifier AS Identifier IN identifiers
                //
                IF (flag)
                    //
                    flag := FALSE
                ELSE
                    //
                    SELF:writer:WriteToken(NULL, ".")
                ENDIF
                SELF:writer:WriteIdentifier(identifier)
            NEXT
            
        PROTECTED VIRTUAL METHOD WriteToken(tokenRole AS TokenRole) AS VOID
            //
            SELF:WriteToken(tokenRole:Token, tokenRole)
            
        PROTECTED VIRTUAL METHOD WriteToken(token AS STRING) AS VOID
            //
            SELF:WriteToken(token, NULL)
            
        PROTECTED VIRTUAL METHOD WriteToken(token AS STRING, tokenRole AS Role) AS VOID
            //
            SELF:writer:WriteToken(tokenRole, token)
            SELF:isAtStartOfLine := FALSE
            SELF:isAfterSpace := FALSE
            
        PROTECTED VIRTUAL METHOD WriteTypeArguments(typeArguments AS System.Collections.Generic.IEnumerable<AstType>) AS VOID
            //
            IF (System.Linq.Enumerable.Any<AstType>(typeArguments))
                //
                SELF:WriteToken(XSRoles.LChevron)
                SELF:WriteCommaSeparatedList(typeArguments)
                SELF:WriteToken(XSRoles.RChevron)
            ENDIF
            
        VIRTUAL METHOD WriteTypeParameters(typeParameters AS System.Collections.Generic.IEnumerable<TypeParameterDeclaration>) AS VOID
            //
            IF (System.Linq.Enumerable.Any<TypeParameterDeclaration>(typeParameters))
                //
                SELF:WriteToken(XSRoles.LChevron)
                SELF:WriteCommaSeparatedList(typeParameters)
                SELF:WriteToken(XSRoles.RChevron)
            ENDIF
            
        PRIVATE METHOD GetMemberReference( node AS AstNode ) AS ISymbol
            LOCAL mbr AS IMember
            LOCAL sym AS ISymbol
            LOCAL declaringType AS IType
            //
            sym := node.GetSymbol()
            IF (((sym == NULL) .AND. (node:Role == Roles.TargetExpression)) .AND. (node:Parent IS InvocationExpression))
                //
                sym := AnnotationExtensions.GetSymbol(node:Parent)
            ENDIF
            IF (((sym != NULL) .AND. (node:Role == Roles.Type)) .AND. (node:Parent IS ObjectCreateExpression))
                //
                sym := node:Parent.GetSymbol()
            ENDIF
            IF ((node IS IdentifierExpression) .AND. (node:Role == Roles.TargetExpression)) .AND. ((node:Parent IS InvocationExpression))
                mbr := sym ASTYPE IMember
                IF (mbr != NULL )
                    //
                    declaringType := mbr:DeclaringType
                    IF ((declaringType != NULL) .AND. (declaringType:Kind == TypeKind.Delegate))
                        //
                        RETURN NULL
                    ENDIF
                ENDIF
            ENDIF
            RETURN sym
            
        PRIVATE METHOD SymbolToCecil( sym AS ISymbol) AS MemberReference
            LOCAL typeDef AS IType
            LOCAL mbr AS IMember
            //
            IF (SELF:system != NULL )
                typeDef := sym ASTYPE IType
                IF (typeDef != NULL)
                    //
                    RETURN NULL // SELF:system:GetCecil(typeDef:GetDefinition())
                ENDIF
                mbr := sym ASTYPE IMember
                IF (mbr != NULL)
                    //
                    RETURN NULL //SELF:system:GetCecil(mbr)
                ENDIF
            ENDIF
            RETURN NULL
            
        PRIVATE METHOD GetElementType( element AS IAnnotatable ) AS ITYPE
            LOCAL eltType AS IType
            LOCAL entity AS IEntity
            //
            eltType := NULL
            entity := SELF:GetElement( element )
            IF ( entity != NULL )
                eltType := entity:DeclaringType
            ENDIF
            //
            RETURN eltType
            
        PRIVATE METHOD GetElement( element AS IAnnotatable ) AS IEntity
            LOCAL resolved AS MemberResolveResult
            LOCAL mbr AS IEntity
            //
            mbr := NULL
            FOREACH ann AS OBJECT IN element:Annotations
                resolved := ann ASTYPE MemberResolveResult
                IF(resolved != NULL)
                    mbr:= resolved:@@Member
                    EXIT
                ENDIF
            NEXT
            RETURN mbr
            
            
        PRIVATE METHOD IsDeclaredInCurrentType( element AS IAnnotatable ) AS LOGIC
            LOCAL invocType AS IType
            //
            invocType := SELF:GetElementType( element )
            IF ( invocType != NULL )
                IF ( SELF:currentType != NULL )
                    RETURN ( invocType:FullName:CompareTo( SELF:currentType:FullName ) == 0 )
                ENDIF
                RETURN FALSE
            ENDIF
            RETURN FALSE
            
        PRIVATE METHOD Prefix( element AS IAnnotatable ) AS VOID
            LOCAL elt AS IEntity
            //
            elt := GetElement( element )
            IF ( elt != NULL )
                IF ( SELF:IsDeclaredInCurrentType( element ) )
                    IF ( elt:IsStatic )
                        //SELF:WriteToken( elt:Name )
                        //SELF:WriteToken( "." )
                    ELSE
                        SELF:WriteKeyword( "SELF" )
                        SELF:WriteToken( ":" )
                    ENDIF
            ELSE
                ENDIF
            ENDIF
            
            
            
            
            END CLASS
            
            
            
    ENUM ClipperState
        MEMBER None
        MEMBER Attribute
        MEMBER ReturnType
        MEMBER Code
    END ENUM 
END NAMESPACE 